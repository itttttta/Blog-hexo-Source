{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1},{"_id":"themes/next/source/tags/index.md","path":"tags/index.md","modified":1},{"_id":"themes/next/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":1},{"_id":"themes/next/source/js/nav-toggle.js","path":"js/nav-toggle.js","modified":1},{"_id":"themes/next/source/js/motion_global.js","path":"js/motion_global.js","modified":1},{"_id":"themes/next/source/js/motion_fallback.js","path":"js/motion_fallback.js","modified":1},{"_id":"themes/next/source/js/lazyload.js","path":"js/lazyload.js","modified":1},{"_id":"themes/next/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":1},{"_id":"themes/next/source/js/helpers.js","path":"js/helpers.js","modified":1},{"_id":"themes/next/source/js/fancy-box.js","path":"js/fancy-box.js","modified":1},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1},{"_id":"themes/next/source/images/bkdefault_avatar.jpg","path":"images/bkdefault_avatar.jpg","modified":1},{"_id":"themes/next/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1},{"_id":"themes/next/source/fonts/icon-linecons/selection.json","path":"fonts/icon-linecons/selection.json","modified":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.woff","path":"fonts/icon-linecons/icomoon.woff","modified":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.ttf","path":"fonts/icon-linecons/icomoon.ttf","modified":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.svg","path":"fonts/icon-linecons/icomoon.svg","modified":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.eot","path":"fonts/icon-linecons/icomoon.eot","modified":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.woff","path":"fonts/icon-icomoon/icomoon.woff","modified":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.ttf","path":"fonts/icon-icomoon/icomoon.ttf","modified":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.svg","path":"fonts/icon-icomoon/icomoon.svg","modified":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.eot","path":"fonts/icon-icomoon/icomoon.eot","modified":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/selection.json","path":"fonts/icon-fifty-shades/selection.json","modified":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.woff","path":"fonts/icon-fifty-shades/icomoon.woff","modified":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.ttf","path":"fonts/icon-fifty-shades/icomoon.ttf","modified":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.svg","path":"fonts/icon-fifty-shades/icomoon.svg","modified":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.eot","path":"fonts/icon-fifty-shades/icomoon.eot","modified":1},{"_id":"themes/next/source/fonts/icon-feather/selection.json","path":"fonts/icon-feather/selection.json","modified":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.woff","path":"fonts/icon-feather/icomoon.woff","modified":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.ttf","path":"fonts/icon-feather/icomoon.ttf","modified":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.svg","path":"fonts/icon-feather/icomoon.svg","modified":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.eot","path":"fonts/icon-feather/icomoon.eot","modified":1},{"_id":"themes/next/source/fonts/icon-default/selection.json","path":"fonts/icon-default/selection.json","modified":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.woff","path":"fonts/icon-default/icomoon.woff","modified":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.ttf","path":"fonts/icon-default/icomoon.ttf","modified":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.svg","path":"fonts/icon-default/icomoon.svg","modified":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.eot","path":"fonts/icon-default/icomoon.eot","modified":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1}],"Cache":[{"_id":"source/_posts/IOS-CoreMotion.md","shasum":"5c24ec47ee5a616f80111b302f5bd96488cb1064","modified":1440378335000},{"_id":"source/_posts/IOS-UI-Tips-之UITabelviewCell-Height.md","shasum":"624e81611f8e07126335e528527ca555d3c280bd","modified":1439877875000},{"_id":"source/_posts/IOS-UIAccelerometer.md","shasum":"17635b57e7aaa33b0e4a1a60cfaf4ec87df34e42","modified":1440378185000},{"_id":"source/_posts/IOS-摇一摇.md","shasum":"583328a627f368e2596c4208a30e52f8c992630d","modified":1440378407000},{"_id":"source/_posts/IOS-播放在线视频.md","shasum":"7e59089dfe149c3d2355e09c7199083a1756d57a","modified":1440379620000},{"_id":"source/_posts/IOS距离传感器.md","shasum":"e89e6d056096ce6ce1e587f676549f0dfaf14484","modified":1440378031000},{"_id":"source/_posts/ImageWithColor.md","shasum":"122f0bb53cd4bbbaa4057ae48884d62cfc532733","modified":1439972996000},{"_id":"source/_posts/Objective-C内存布局.md","shasum":"4f30fed4e6715113ca8da13959841007e3833c55","modified":1439886677000},{"_id":"source/_posts/Objective-C消息机制的原理.md","shasum":"084a55e591cf4c86bb0f7b2c299ad2881abe7918","modified":1439802730000},{"_id":"source/_posts/block写递归.md","shasum":"14a7cae2106a497de08a03d6d77fce88d8b3aed5","modified":1440056278000},{"_id":"source/_posts/hello-world.md","shasum":"eba1c6b3dcf47cf71e7dd6cdd4360098d1c86602","modified":1439878701000},{"_id":"source/_posts/关于swift.md","shasum":"9ba675cb150c475820fabc730c5ca23e2a0776c8","modified":1440124475000},{"_id":"source/_posts/如何建立一个简单的图片浏览器.md","shasum":"53dc8928178257db85283e88f0970d7083a9029b","modified":1440119778000},{"_id":"source/_posts/改变nstimer的runloopmode.md","shasum":"0b2514325c5da9b1dbf1419bdfb7cae38d83f0b7","modified":1440150212000},{"_id":"source/_posts/深入理解Objective-C：Category.md","shasum":"92c959e97f74d792b390e5536fa009f957363ef3","modified":1439973170000},{"_id":"source/_posts/隐藏UInavigationBar下的黑边.md","shasum":"3645dc740b250e4566988a49479293b03412561b","modified":1439974758000},{"_id":"source/_posts/蓝牙设备.md","shasum":"f251fdb2b5deff4e242b8ee52460769ea71d3e62","modified":1440377833000},{"_id":"source/about/index.md","shasum":"1030e23edbbd60f2b4ca052fbd9715c33d584c3a","modified":1439887411000},{"_id":"source/categories/index.md","shasum":"dcc2053a52a4cfa2ff50d41da28329a61042df53","modified":1439878873000},{"_id":"source/tags/index.md","shasum":"5e46585630c6128277237fbdda32c417f52c4ff5","modified":1440060256000},{"_id":"themes/next/source/css/_common/_page/home.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1439796017000},{"_id":"themes/next/source/css/_mixins/Mist.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1439796017000},{"_id":"themes/next/source/css/_mixins/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1439796017000},{"_id":"themes/next/source/css/_mixins/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1439796017000},{"_id":"themes/next/source/css/_variables/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1439796017000},{"_id":"themes/next/source/css/_variables/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1439796017000},{"_id":"themes/next/README.en.md","shasum":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1439796017000},{"_id":"themes/next/README.md","shasum":"3319de8565699fc9642f76c41ee96b50f2234b6a","modified":1439796017000},{"_id":"themes/next/_config.yml","shasum":"0345fb198f41e77ac0f1b2af6ba3f2754b3cc9b4","modified":1440382065000},{"_id":"themes/next/bower.json","shasum":"1bdb0641bdcb9b5b154d2e379c57fe5675f06b9c","modified":1439796017000},{"_id":"themes/next/languages/de.yml","shasum":"7a8de0e5665c52a1bf168c1e7dd222c8a74fb0ab","modified":1439796017000},{"_id":"themes/next/languages/default.yml","shasum":"7e65ef918f16d0189055deb5f1616b9dedcb1920","modified":1439796017000},{"_id":"themes/next/languages/en.yml","shasum":"7e65ef918f16d0189055deb5f1616b9dedcb1920","modified":1439796017000},{"_id":"themes/next/languages/fr-FR.yml","shasum":"6d097445342a9fb5235afea35d65bf5271b772f0","modified":1439796017000},{"_id":"themes/next/languages/ru.yml","shasum":"b4a827b9ddac9d5f6dca096fe513aeafb46a3e93","modified":1439796017000},{"_id":"themes/next/languages/zh-Hans.yml","shasum":"8af76df5557561050a950bdd7091d3bb3939c5c0","modified":1439796017000},{"_id":"themes/next/languages/zh-hk.yml","shasum":"3fc38103c9efa6f6c37149adbddb014ff85ec849","modified":1439796017000},{"_id":"themes/next/languages/zh-tw.yml","shasum":"8897a06e521b36c7a1226c72057c8357611eded8","modified":1439796017000},{"_id":"themes/next/layout/_layout.swig","shasum":"54f049f8045d386587c1e5d9761c517553b79712","modified":1439796017000},{"_id":"themes/next/layout/_macro/post-collapse.swig","shasum":"42927bdde998cefd3cf4f19b0476d69bd9e5116a","modified":1439796017000},{"_id":"themes/next/layout/_macro/post.swig","shasum":"598b3085b6b74f4664eb66e6ae8737920e07d7a9","modified":1439796017000},{"_id":"themes/next/layout/_macro/sidebar.swig","shasum":"b0c467b42073270db7db41907ce8881f64bf3793","modified":1439796017000},{"_id":"themes/next/layout/_partials/footer.swig","shasum":"1c525945210bb2dc0f1bf2bfd6e7b5ea07b6923b","modified":1439883342000},{"_id":"themes/next/layout/_partials/head.swig","shasum":"fc9ab6752cbdd13f563b3969d039ef7cf05ab046","modified":1439796017000},{"_id":"themes/next/layout/_partials/header.swig","shasum":"eefb48589ed5b0894ac46883608618ac8a4dba3c","modified":1439796017000},{"_id":"themes/next/layout/_partials/old-browsers.swig","shasum":"dbbfea810bf3a2ed9c83b9a6683037175aacfc67","modified":1439796017000},{"_id":"themes/next/layout/_partials/pagination.swig","shasum":"d6c7f04eee4388d8f133eb5526b7c0875c321a30","modified":1439796017000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","shasum":"00c2b49f6289198b0b2b4e157e4ee783277f32a7","modified":1439796017000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","shasum":"2f92046e0b50ebd65abb7045b1cbbfc50abbb034","modified":1439796017000},{"_id":"themes/next/layout/_partials/search.swig","shasum":"64f14da26792a17bc27836c4e9d83190175f36e6","modified":1439796017000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","shasum":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1439796017000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","shasum":"63315fcf210799f894208c9f512737096df84962","modified":1439796017000},{"_id":"themes/next/layout/_scripts/analytics/baidu-analytics.swig","shasum":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1439796017000},{"_id":"themes/next/layout/_scripts/analytics/google-analytics.swig","shasum":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1439796017000},{"_id":"themes/next/layout/_scripts/analytics.swig","shasum":"0ebbf76c2317faa8ba31365adba59331c2e0262c","modified":1439796017000},{"_id":"themes/next/layout/_scripts/baidushare.swig","shasum":"d726361945437cf6e48067b3dd041b7e36e98d85","modified":1439796017000},{"_id":"themes/next/layout/_scripts/bootstrap.scrollspy.swig","shasum":"85295f126836b95f0837d03e58228bb3cf8c4490","modified":1439796017000},{"_id":"themes/next/layout/_scripts/comments/disqus.swig","shasum":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1439796017000},{"_id":"themes/next/layout/_scripts/comments/duoshuo.swig","shasum":"3351ea62225933f8045d036a79654e19e84d19a7","modified":1439796017000},{"_id":"themes/next/layout/_scripts/fancy-box.swig","shasum":"41b4ff1446060c88c33bf666a32277dcf12129f0","modified":1439796017000},{"_id":"themes/next/layout/_scripts/helpers.swig","shasum":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1439796017000},{"_id":"themes/next/layout/_scripts/mathjax.swig","shasum":"abc52fefb276c52cbb19de5c214521dfcf2a10fd","modified":1439796017000},{"_id":"themes/next/layout/_scripts/motion.swig","shasum":"817705bfd1a1282cb6bf59094afe507e11455aa0","modified":1439796017000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","shasum":"b63ef233886538f30ced60344ac15d25e5f3e0af","modified":1439796017000},{"_id":"themes/next/layout/archive.swig","shasum":"0c3ce594759f347ea90a4ce592a7a18e2ae4cc5c","modified":1439796017000},{"_id":"themes/next/layout/category.swig","shasum":"d6b3e1dc5e0b8deade9a084c463126e70188ee9b","modified":1439796017000},{"_id":"themes/next/layout/index.swig","shasum":"fdc801f0da71a2eb205ce9c0b12f156b219fdc9c","modified":1439796017000},{"_id":"themes/next/layout/page.swig","shasum":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1439796017000},{"_id":"themes/next/layout/post.swig","shasum":"a84457e8ced46e63bc7a8a9e0541a6ba53122a92","modified":1439796017000},{"_id":"themes/next/layout/tag.swig","shasum":"aab44af54fcbc66fea4ad12b2767ffca3eadd451","modified":1439796017000},{"_id":"themes/next/scripts/merge-configs.js","shasum":"dfd147d1317e56d283f5e779f00608e913603b51","modified":1439796017000},{"_id":"themes/next/scripts/tags/center-quote.js","shasum":"37274f743c2054244dcbbde56fba9ff353414281","modified":1439796017000},{"_id":"themes/next/scripts/tags/full-image.js","shasum":"0d69739d1bad5861a4a6ff2db511c3669783e438","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/back-to-top.styl","shasum":"88cd66910260006aa8e9e795df4948d4b67bfa11","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/buttons.styl","shasum":"81063e0979f04a0f9af37f321d7321dda9abf593","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/comments.styl","shasum":"54e73681ba6f57ef961138f94d2ee8ac845990c3","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/duoshuo.styl","shasum":"c307f1e4827d7cb82816a5f9de109ae14ed4199c","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/gallery.styl","shasum":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/jiathis.styl","shasum":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/pagination.styl","shasum":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/posts-collapse.styl","shasum":"8f9e8f5f65956ccf1d52ff8526392803dff579d3","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","shasum":"4b82dbbb6e536e6e8ee3cec6e62c2fd4bea60a09","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/posts-type.styl","shasum":"40b593134bf96d1d6095b3439d47820659d7f10b","modified":1439796017000},{"_id":"themes/next/source/css/_common/_component/tag-cloud.styl","shasum":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1439796017000},{"_id":"themes/next/source/css/_common/_core/base.styl","shasum":"e79a08484b191dca14ccfc005053eb95786dafae","modified":1439796017000},{"_id":"themes/next/source/css/_common/_core/helpers.styl","shasum":"41a31d651b60b4f458fc56a1d191dfbbdcb6d794","modified":1439796017000},{"_id":"themes/next/source/css/_common/_core/normalize.styl","shasum":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1439796017000},{"_id":"themes/next/source/css/_common/_core/scaffolding.styl","shasum":"cbd7f1d5c72e3024b5d70dafb6ca93e2723652ab","modified":1439796017000},{"_id":"themes/next/source/css/_common/_core/tables.styl","shasum":"f142a185fda68bc579e89ead9a31bc8fa0f3ca8c","modified":1439796017000},{"_id":"themes/next/source/css/_common/_fonts/icon-default.styl","shasum":"8b809aef383bebaeb3f282b47675f3a364ce3569","modified":1439796017000},{"_id":"themes/next/source/css/_common/_fonts/icon-feather.styl","shasum":"80413afacfa656322100ce1900fed1ebcd8f8f44","modified":1439796017000},{"_id":"themes/next/source/css/_common/_fonts/icon-fifty-shades.styl","shasum":"249f75bafa26b99d272352c0646e7497ea680b39","modified":1439796017000},{"_id":"themes/next/source/css/_common/_fonts/icon-font.styl","shasum":"ec3f86739bede393cafcd3e31052c01115ae20d6","modified":1439796017000},{"_id":"themes/next/source/css/_common/_fonts/icon-linecons.styl","shasum":"9cdbedb3627ac941cfb063b152abe5a75c3c699a","modified":1439796017000},{"_id":"themes/next/source/css/_common/_page/archive.styl","shasum":"dff879f55ca65fa79c07e9098719e53eeea7ac88","modified":1439796017000},{"_id":"themes/next/source/css/_common/_page/categories.styl","shasum":"4f696a2eaeee2f214adcf273eab25c62a398077a","modified":1439796017000},{"_id":"themes/next/source/css/_common/_page/post-detail.styl","shasum":"73796f6f13caa7151a2ee8e55755627e0d189f55","modified":1439796017000},{"_id":"themes/next/source/css/_common/_section/body.styl","shasum":"ca1a4766cbe25baac757c6b47a4858d221afdc40","modified":1439796017000},{"_id":"themes/next/source/css/_common/_section/footer.styl","shasum":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1439796017000},{"_id":"themes/next/source/css/_common/_section/header.styl","shasum":"ba501332fb111bd72dc0777f2e1c8a29ad538ff9","modified":1439796017000},{"_id":"themes/next/source/css/_common/_section/layout.styl","shasum":"4daaadd156ece64ae05908ad6bb0159c8a27c071","modified":1439796017000},{"_id":"themes/next/source/css/_common/_section/media.styl","shasum":"fa9809d2ecc753cf32f70803c1d0821c405211f4","modified":1439796017000},{"_id":"themes/next/source/css/_common/_section/sidebar.styl","shasum":"d57e1769ebd2c472d2b27d17a706d3f564f94033","modified":1439796017000},{"_id":"themes/next/source/css/_common/_vendor/highlight/highlight.styl","shasum":"f3529b7da284c4b859429573c9b1004d32937e40","modified":1439796017000},{"_id":"themes/next/source/css/_common/_vendor/highlight/theme.styl","shasum":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1439796017000},{"_id":"themes/next/source/css/_custom/custom.styl","shasum":"68b6859fb48fe8358e567fc324f218cecfc3a533","modified":1439796017000},{"_id":"themes/next/source/css/_mixins/base.styl","shasum":"66985fe77bd323f7f8f634908e17166f51e96e95","modified":1439796017000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","shasum":"f3f4fac628d0b588cb40795d498110d33b11ce26","modified":1439796017000},{"_id":"themes/next/source/css/_schemes/default/_menu.styl","shasum":"4bba29cece65ffc5122f4e052063dea4439fe4ae","modified":1439796017000},{"_id":"themes/next/source/css/_schemes/default/_search.styl","shasum":"c524bccdc554349106d1c8be9c3f275d4c0d4281","modified":1439796017000},{"_id":"themes/next/source/css/_schemes/default/index.styl","shasum":"2588e55132e10d82c0608f03c2c72a2bace8fa4e","modified":1439796017000},{"_id":"themes/next/source/css/_variables/Mist.styl","shasum":"f5dda1ca48c1b73a0bd34e08413de57699f24083","modified":1439796017000},{"_id":"themes/next/source/css/_variables/base.styl","shasum":"cd2066c448fb37c5642173acc2d53e249cc0c196","modified":1439796017000},{"_id":"themes/next/source/css/main.styl","shasum":"b05c342e94ded24a5f2b203cedf77d3faa817fd5","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-default/icomoon.eot","shasum":"90763e97be18be78e65749075225cceeddc6fa8a","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-default/icomoon.svg","shasum":"f92ad8cddc250f0bb5ca466fca95d321987e127e","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-default/icomoon.ttf","shasum":"c093408e6030221cafc1f79d897f1fb5283c1178","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-default/icomoon.woff","shasum":"dbe0368f2a65d87b13234cfea29d9783892fc7a8","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-default/selection.json","shasum":"dc07c29f687315f9458f6b251c214768af865fb2","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.eot","shasum":"11554b9e9d5b9f535ba96cbb27d45d8c8f1689fd","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.svg","shasum":"d5eb756eefda9b454dcb23c2b1cefd4051d18d41","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.ttf","shasum":"b2bbae4b613403cf61ad25037913378da1c07b8f","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.woff","shasum":"2ea1c59c17422798e64ee6f4e9ce1f7aff1a06a5","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-feather/selection.json","shasum":"06ea91e3f98ebe1080087acad4356802bc5b6ebf","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.eot","shasum":"da86ba5df72d1288de9e9633e5f528062dd427d5","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.svg","shasum":"1a4afd739e1f8eb8d430dbdd29e36a9999802e8d","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.ttf","shasum":"72fe82e1f3db52414eed706952d385af241cb196","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.woff","shasum":"4de6a74f523dee33d95dde61caae5809f9a5d448","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.eot","shasum":"301fcf00c24750dddf1c529f944ca62c7f1a217d","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.svg","shasum":"e316347805eb93425faa678611c5e42a7152da8f","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-fifty-shades/selection.json","shasum":"fdd09098d1c3688e2c88cf33fd51e76b383b6d7f","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.ttf","shasum":"f399713d1c9400d4d3373e38991a7e362a754a94","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.woff","shasum":"05f1ec0bd307da5e731a86eb4961589a6042aebb","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.eot","shasum":"e2d7f040428a632f3c50bfa94083b759936effc2","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.svg","shasum":"808eaf7d61f7e67c76976265c885e79c36920f0b","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.ttf","shasum":"078068206684e4f185b0187ad3cee16f54a287d7","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.woff","shasum":"0b07ee6ceda3b1bceb40c1e7379b3aa48dcc15a8","modified":1439796017000},{"_id":"themes/next/source/fonts/icon-linecons/selection.json","shasum":"db4ce25d31449ecc6685b32e145252103967bb5c","modified":1439796017000},{"_id":"themes/next/source/images/avatar.jpeg","shasum":"eb4f64ca454868117b0ce33aaa7bb0ca209937b5","modified":1439799037000},{"_id":"themes/next/source/images/bkdefault_avatar.jpg","shasum":"b687bb4bfbe35a32b592c24d652ba80cfdc770fc","modified":1439796017000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1439796017000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1439796017000},{"_id":"themes/next/source/images/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1439796017000},{"_id":"themes/next/source/images/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1439796017000},{"_id":"themes/next/source/images/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1439796017000},{"_id":"themes/next/source/images/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1439796017000},{"_id":"themes/next/source/images/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1439796017000},{"_id":"themes/next/source/images/loading.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1439796017000},{"_id":"themes/next/source/images/placeholder.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1439796017000},{"_id":"themes/next/source/images/searchicon.png","shasum":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1439796017000},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1439796017000},{"_id":"themes/next/source/js/fancy-box.js","shasum":"116cafc741e048497287121a508d7a54c050c70c","modified":1439796017000},{"_id":"themes/next/source/js/helpers.js","shasum":"c2117b0ec653df4c45dd9d9575b190cbe1035335","modified":1439796017000},{"_id":"themes/next/source/js/hook-duoshuo.js","shasum":"a34b872747db57bf2577155c3169e552916090b5","modified":1439796017000},{"_id":"themes/next/source/js/lazyload.js","shasum":"b92e9acdc7afc15468314c03f4a643b0c93944cf","modified":1439796017000},{"_id":"themes/next/source/js/motion_fallback.js","shasum":"a767d522c65a8b2fbad49135c9332135c6785c3e","modified":1439796017000},{"_id":"themes/next/source/js/motion_global.js","shasum":"367e329b2cc19c6b7634ea2917a218c84a22ec17","modified":1439796017000},{"_id":"themes/next/source/js/nav-toggle.js","shasum":"78b59f1beb12adea0d7f9bcf4377cb699963f220","modified":1439796017000},{"_id":"themes/next/source/js/ua-parser.min.js","shasum":"acf0ee6a47ffb7231472b56e43996e3f947c258a","modified":1439796017000},{"_id":"themes/next/source/tags/index.md","shasum":"2754faa0103ade7256b27c9a1f9384cf427d07ab","modified":1439878507000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","shasum":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","shasum":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1439796017000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","shasum":"53360764b429c212f424399384417ccc233bb3be","modified":1439796017000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","shasum":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1439796017000},{"_id":"themes/next/source/vendors/fastclick/README.md","shasum":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1439796017000},{"_id":"themes/next/source/vendors/fastclick/bower.json","shasum":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1439796017000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","shasum":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1439796017000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1439796017000},{"_id":"themes/next/source/vendors/velocity/bower.json","shasum":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1439796017000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1439796017000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1439796017000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1439796017000},{"_id":"themes/next/test/helpers.js","shasum":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1439796017000},{"_id":"themes/next/test/intern.js","shasum":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1439796017000},{"_id":"themes/next/source/vendors/jquery/index.js","shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1439796017000},{"_id":"themes/next/source/vendors/velocity/velocity.js","shasum":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1439796017000},{"_id":"public/vendors/velocity/velocity.ui.min.js","modified":1440382076654,"shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908"},{"_id":"public/vendors/velocity/velocity.ui.js","modified":1440382076656,"shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df"},{"_id":"public/vendors/velocity/velocity.min.js","modified":1440382076658,"shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6"},{"_id":"public/vendors/velocity/velocity.js","modified":1440382076659,"shasum":"9f08181baea0cc0e906703b7e5df9111b9ef3373"},{"_id":"public/vendors/velocity/bower.json","modified":1440382076662,"shasum":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409"},{"_id":"public/vendors/jquery/index.js","modified":1440382076663,"shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276"},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","modified":1440382076664,"shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18"},{"_id":"public/vendors/fastclick/lib/fastclick.js","modified":1440382076666,"shasum":"06cef196733a710e77ad7e386ced6963f092dc55"},{"_id":"public/vendors/fastclick/bower.json","modified":1440382076667,"shasum":"4dcecf83afddba148464d5339c93f6d0aa9f42e9"},{"_id":"public/vendors/fastclick/README.html","modified":1440382076672,"shasum":"4a6074903daa9004301ef30a6fb96556ba3eab60"},{"_id":"public/vendors/fastclick/LICENSE","modified":1440382076678,"shasum":"dcd5b6b43095d9e90353a28b09cb269de8d4838e"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","modified":1440382076679,"shasum":"53360764b429c212f424399384417ccc233bb3be"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","modified":1440382076684,"shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","modified":1440382076686,"shasum":"5f163444617b6cf267342f06ac166a237bb62df9"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1440382076688,"shasum":"53e194f4a72e649c04fb586dd57762b8c022800b"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1440382076690,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1440382076691,"shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1440382076692,"shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1440382076695,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1440382076697,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","modified":1440382076699,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","modified":1440382076701,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","modified":1440382076703,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","modified":1440382076705,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","modified":1440382076706,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/vendors/fancybox/source/blank.gif","modified":1440382076709,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/tags/index.html","modified":1440382076778,"shasum":"78cad042e492bde58677100d62dfd4f946775212"},{"_id":"public/js/ua-parser.min.js","modified":1440382076780,"shasum":"acf0ee6a47ffb7231472b56e43996e3f947c258a"},{"_id":"public/js/nav-toggle.js","modified":1440382076781,"shasum":"78b59f1beb12adea0d7f9bcf4377cb699963f220"},{"_id":"public/js/motion_global.js","modified":1440382076782,"shasum":"367e329b2cc19c6b7634ea2917a218c84a22ec17"},{"_id":"public/js/motion_fallback.js","modified":1440382076783,"shasum":"a767d522c65a8b2fbad49135c9332135c6785c3e"},{"_id":"public/js/lazyload.js","modified":1440382076784,"shasum":"b92e9acdc7afc15468314c03f4a643b0c93944cf"},{"_id":"public/js/hook-duoshuo.js","modified":1440382076785,"shasum":"9881b19132ad90dffd82c53947e4c356e30353e7"},{"_id":"public/js/helpers.js","modified":1440382076786,"shasum":"c2117b0ec653df4c45dd9d9575b190cbe1035335"},{"_id":"public/js/fancy-box.js","modified":1440382076787,"shasum":"116cafc741e048497287121a508d7a54c050c70c"},{"_id":"public/js/bootstrap.scrollspy.js","modified":1440382076788,"shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625"},{"_id":"public/images/searchicon.png","modified":1440382076792,"shasum":"67727a6a969be0b2659b908518fa6706eed307b8"},{"_id":"public/images/placeholder.gif","modified":1440382076795,"shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b"},{"_id":"public/images/loading.gif","modified":1440382076798,"shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b"},{"_id":"public/images/cc-zero.svg","modified":1440382076801,"shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030"},{"_id":"public/images/cc-by.svg","modified":1440382076806,"shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e"},{"_id":"public/images/cc-by-sa.svg","modified":1440382076811,"shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e"},{"_id":"public/images/cc-by-nd.svg","modified":1440382076815,"shasum":"c563508ce9ced1e66948024ba1153400ac0e0621"},{"_id":"public/images/cc-by-nc.svg","modified":1440382076817,"shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7"},{"_id":"public/images/cc-by-nc-sa.svg","modified":1440382076821,"shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e"},{"_id":"public/images/cc-by-nc-nd.svg","modified":1440382076824,"shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564"},{"_id":"public/images/bkdefault_avatar.jpg","modified":1440382076826,"shasum":"b687bb4bfbe35a32b592c24d652ba80cfdc770fc"},{"_id":"public/images/avatar.jpeg","modified":1440382076828,"shasum":"eb4f64ca454868117b0ce33aaa7bb0ca209937b5"},{"_id":"public/fonts/icon-linecons/selection.json","modified":1440382076832,"shasum":"68da6ea1b3ab9355d42694bf5745071cdefa4a65"},{"_id":"public/fonts/icon-linecons/icomoon.woff","modified":1440382076834,"shasum":"0b07ee6ceda3b1bceb40c1e7379b3aa48dcc15a8"},{"_id":"public/fonts/icon-linecons/icomoon.ttf","modified":1440382076836,"shasum":"078068206684e4f185b0187ad3cee16f54a287d7"},{"_id":"public/fonts/icon-linecons/icomoon.svg","modified":1440382076838,"shasum":"808eaf7d61f7e67c76976265c885e79c36920f0b"},{"_id":"public/fonts/icon-linecons/icomoon.eot","modified":1440382076841,"shasum":"e2d7f040428a632f3c50bfa94083b759936effc2"},{"_id":"public/fonts/icon-icomoon/icomoon.woff","modified":1440382076844,"shasum":"05f1ec0bd307da5e731a86eb4961589a6042aebb"},{"_id":"public/fonts/icon-icomoon/icomoon.ttf","modified":1440382076846,"shasum":"f399713d1c9400d4d3373e38991a7e362a754a94"},{"_id":"public/fonts/icon-icomoon/icomoon.svg","modified":1440382076847,"shasum":"e316347805eb93425faa678611c5e42a7152da8f"},{"_id":"public/fonts/icon-icomoon/icomoon.eot","modified":1440382076848,"shasum":"301fcf00c24750dddf1c529f944ca62c7f1a217d"},{"_id":"public/fonts/icon-fifty-shades/selection.json","modified":1440382076851,"shasum":"e5a5042e8e516b1d30fa3b1206d2c74921cec72b"},{"_id":"public/fonts/icon-fifty-shades/icomoon.woff","modified":1440382076853,"shasum":"4de6a74f523dee33d95dde61caae5809f9a5d448"},{"_id":"public/fonts/icon-fifty-shades/icomoon.ttf","modified":1440382076854,"shasum":"72fe82e1f3db52414eed706952d385af241cb196"},{"_id":"public/fonts/icon-fifty-shades/icomoon.svg","modified":1440382076855,"shasum":"1a4afd739e1f8eb8d430dbdd29e36a9999802e8d"},{"_id":"public/fonts/icon-fifty-shades/icomoon.eot","modified":1440382076857,"shasum":"da86ba5df72d1288de9e9633e5f528062dd427d5"},{"_id":"public/fonts/icon-feather/selection.json","modified":1440382076859,"shasum":"d95a90b0d541e48b049902090c0d008ad92b4115"},{"_id":"public/fonts/icon-feather/icomoon.woff","modified":1440382076864,"shasum":"2ea1c59c17422798e64ee6f4e9ce1f7aff1a06a5"},{"_id":"public/fonts/icon-feather/icomoon.ttf","modified":1440382076869,"shasum":"b2bbae4b613403cf61ad25037913378da1c07b8f"},{"_id":"public/fonts/icon-feather/icomoon.svg","modified":1440382076875,"shasum":"d5eb756eefda9b454dcb23c2b1cefd4051d18d41"},{"_id":"public/fonts/icon-feather/icomoon.eot","modified":1440382076881,"shasum":"11554b9e9d5b9f535ba96cbb27d45d8c8f1689fd"},{"_id":"public/fonts/icon-default/selection.json","modified":1440382076883,"shasum":"ff1b9b78eced4d0368d14cc192ac67a0dd498593"},{"_id":"public/fonts/icon-default/icomoon.woff","modified":1440382076886,"shasum":"dbe0368f2a65d87b13234cfea29d9783892fc7a8"},{"_id":"public/fonts/icon-default/icomoon.ttf","modified":1440382076887,"shasum":"c093408e6030221cafc1f79d897f1fb5283c1178"},{"_id":"public/fonts/icon-default/icomoon.svg","modified":1440382076888,"shasum":"f92ad8cddc250f0bb5ca466fca95d321987e127e"},{"_id":"public/fonts/icon-default/icomoon.eot","modified":1440382076889,"shasum":"90763e97be18be78e65749075225cceeddc6fa8a"},{"_id":"public/css/main.css","modified":1440382077132,"shasum":"a87fd7b10ac667ea4c0b6fd2ebc73cfa3e44f7c2"},{"_id":"public/categories/index.html","modified":1440382077269,"shasum":"83ab0b6486562cb151f08511eb5bbc7a2630fe2b"},{"_id":"public/about/index.html","modified":1440382077312,"shasum":"789193be2db5ae8fef6bfe4d1d1578d13cd83a79"},{"_id":"public/2015/08/24/IOS-播放在线视频/index.html","modified":1440382077368,"shasum":"08186e3b5eef8c3a0a46577b11048b18487c3044"},{"_id":"public/2015/08/24/IOS-摇一摇/index.html","modified":1440382077440,"shasum":"f7c6043856e65686a65dd7e0fe7a87acd6df7f36"},{"_id":"public/2015/08/24/IOS-CoreMotion/index.html","modified":1440382077514,"shasum":"69577f5e721774b5b17c46db74dd36f2c8aae29c"},{"_id":"public/2015/08/24/IOS-UIAccelerometer/index.html","modified":1440382077571,"shasum":"386efe3ae6ced13c92d179e10e70977ac5e6dfdd"},{"_id":"public/2015/08/24/IOS距离传感器/index.html","modified":1440382077644,"shasum":"a05fb0eccf88bb36aa8cdf8dbde049bfe23ec13b"},{"_id":"public/2015/08/24/蓝牙设备/index.html","modified":1440382077730,"shasum":"56598802120aed53d729ee08e4a7a4e91a88cb33"},{"_id":"public/2015/08/21/改变nstimer的runloopmode/index.html","modified":1440382077763,"shasum":"e3d88e6ace3a1cd3a78ca37ca6c7572c1c9d5ee9"},{"_id":"public/2015/08/21/关于swift/index.html","modified":1440382077810,"shasum":"522aad1795f28585f49a118ef4b5e7ed0070d33c"},{"_id":"public/2015/08/20/block写递归/index.html","modified":1440382077845,"shasum":"ccdc9fdd4b2db5518f27ccf68396785361d0316e"},{"_id":"public/2015/08/19/隐藏UInavigationBar下的黑边/index.html","modified":1440382077897,"shasum":"9d8f99d143546769c384254309d54d56e22ccc94"},{"_id":"public/2015/08/19/ImageWithColor/index.html","modified":1440382077937,"shasum":"a6cd17008f6be88b665ddc5a295f46cc9c50fd11"},{"_id":"public/2015/08/19/如何建立一个简单的图片浏览器/index.html","modified":1440382077986,"shasum":"fb354411d433fd19d3acbebbdf114d3317de22d6"},{"_id":"public/2015/08/18/深入理解Objective-C：Category/index.html","modified":1440382078058,"shasum":"a15d13adb0c9443b3055324fdf69c6694fe5f750"},{"_id":"public/2015/08/18/IOS-UI-Tips-之UITabelviewCell-Height/index.html","modified":1440382078092,"shasum":"f735f0976f8618c23244a3344c89d7ec88866609"},{"_id":"public/2015/08/17/Objective-C内存布局/index.html","modified":1440382078149,"shasum":"87b18699cd6a40f006bd617659491a0b35b42e54"},{"_id":"public/2015/08/17/Objective-C消息机制的原理/index.html","modified":1440382078192,"shasum":"5450771464f85ee84497a2f3a1573ae75901f7a0"},{"_id":"public/2015/08/15/hello-world/index.html","modified":1440382078236,"shasum":"6b4e96990975fe2ac00f29a37e3f328fef729361"},{"_id":"public/archives/index.html","modified":1440382078340,"shasum":"d7f9044b1266020571631a115066a1f004c36cb7"},{"_id":"public/archives/page/2/index.html","modified":1440382078415,"shasum":"3f525e4b3f084af0185b9ca82fd2f0077e0fdc7b"},{"_id":"public/archives/2015/index.html","modified":1440382078497,"shasum":"346218d42b27d3f37137ddf15d7b0d61642892c2"},{"_id":"public/archives/2015/page/2/index.html","modified":1440382078571,"shasum":"1d4da2033704df4c069de6d5849c2db7e07ea568"},{"_id":"public/archives/2015/08/index.html","modified":1440382078669,"shasum":"7cf8d808fb374f2bfffe64caeedb41e030fd49ce"},{"_id":"public/archives/2015/08/page/2/index.html","modified":1440382078806,"shasum":"bbaf03a3d6b794352c54703e0422aa7dc1d35df9"},{"_id":"public/categories/NSRunLoop/index.html","modified":1440382078868,"shasum":"6140404a368aa5519b469d905fe1018bae80b2a5"},{"_id":"public/categories/随笔/index.html","modified":1440382078903,"shasum":"3c61aed0a251f0912274e0803c399a23a0a5d616"},{"_id":"public/atom.xml","modified":1440382078905,"shasum":"8299b311ba6cc8e9166f9bd72a9ca859b0a72a1b"},{"_id":"public/index.html","modified":1440382078975,"shasum":"bac107a214b73b18d466be791008c0dba84b9090"},{"_id":"public/page/2/index.html","modified":1440382079026,"shasum":"2a76ac001a412deda8d72026dd72573f00656840"},{"_id":"public/tags/IOS/index.html","modified":1440382079053,"shasum":"7f674885b834886ca0c6297338ad990224b7d1d6"},{"_id":"public/tags/实用小工具/index.html","modified":1440382079082,"shasum":"da127beb64520ea1eaf95e7bb13bbe8ff5dcf9c8"},{"_id":"public/tags/Objective-C/index.html","modified":1440382079105,"shasum":"2142d4a3d2d31e076d2235da39fdc1f6d570942d"},{"_id":"public/tags/NSRunLoop/index.html","modified":1440382079128,"shasum":"722da3c5148ee1d8d934b1936333313d2f42845c"},{"_id":"public/tags/自定义控件/index.html","modified":1440382079157,"shasum":"0d78f6bc60fd6dbc736b6586f9972792b68c4592"},{"_id":"public/tags/随笔/index.html","modified":1440382079182,"shasum":"8c89aaf8db394d8494a94cf8ddcd3d947d8de7b5"},{"_id":"public/tags/Block/index.html","modified":1440382079210,"shasum":"a2f9ff2144f8a9c687b60eb66577ba2ab04231ae"},{"_id":"public/tags/UI/index.html","modified":1440382079235,"shasum":"00d18e8783b8180234b084bed320fac8d2629d9d"}],"Category":[{"name":"NSRunLoop","_id":"cidpaaq8a000fovfyads9vex6"},{"name":"随笔","_id":"cidpaaq8e000novfy5q91yvu9"}],"Data":[],"Page":[{"title":"云标签","date":"2015-08-20T08:32:28.000Z","type":"tags","tags":"Objective-C","_content":"","source":"tags/index.md","raw":"title: 云标签\ndate: 2015-08-20 16:32:28\ntype: \"tags\"\ntags: Objective-C\n\n---","updated":"2015-08-20T08:44:16.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cidpaaq7r0003ovfyv6xd6xrg"},{"title":"categories","date":"2015-08-18T06:21:13.000Z","_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2015-08-18 14:21:13\n---\n","updated":"2015-08-18T06:21:13.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cidpaaq830004ovfyiadqd73w"},{"title":"about","date":"2015-08-18T06:32:50.000Z","_content":"**我想说点什么,想想还是算了,我就是来熟练一下mb语法的,好了就说这么多了.\n**","source":"about/index.md","raw":"title: about\ndate: 2015-08-18 14:32:50\n---\n**我想说点什么,想想还是算了,我就是来熟练一下mb语法的,好了就说这么多了.\n**","updated":"2015-08-18T08:43:31.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cidpaaq840005ovfyq86pu5zb"}],"Post":[{"title":"IOS-CoreMotion","date":"2015-08-24T01:04:52.000Z","_content":"```\n#import \"ViewController.h\"\n#import <CoreMotion/CoreMotion.h>\n\n@interface ViewController ()\n@property (nonatomic, strong) CMMotionManager *mgr;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 1.创建coreMotion管理者\n    self.mgr = [[CMMotionManager alloc] init];\n    \n     if (self.mgr.isAccelerometerAvailable) {\n          // 3.开始采样\n         [self.mgr startAccelerometerUpdates]; // pull\n     }else\n     {\n         NSLog(@\"加速计不可用\");\n     }\n\n}\n\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    CMAcceleration acceleration = self.mgr.accelerometerData.acceleration;\n    \n     NSLog(@\"x = %f y = %f z = %f\", acceleration.x, acceleration.y , acceleration.z);\n}\n\n- (void)push\n{\n    // 1.创建coreMotion管理者\n    //    CMMotionManager *mgr = [[CMMotionManager alloc] init];\n    self.mgr = [[CMMotionManager alloc] init];\n    \n    // 2.判断加速计是否可用\n    if (self.mgr.isAccelerometerAvailable) {\n        /*\n         isAccelerometerActive 是否正在采集\n         accelerometerData 采集到得数据\n         startAccelerometerUpdates  pull\n         startAccelerometerUpdatesToQueue  push\n         stopAccelerometerUpdates 停止采集\n         accelerometerUpdateInterval 采样时间\n         */\n        // 3.设置采样时间\n        self.mgr.accelerometerUpdateInterval = 1 / 30.0;\n        // 4.开始采样\n        \n        [self.mgr startAccelerometerUpdatesToQueue:[NSOperationQueue mainQueue] withHandler:^(CMAccelerometerData *accelerometerData, NSError *error) {\n            // 这个block是采集到数据时就会调用\n            if (error) return ;\n            CMAcceleration acceleration = accelerometerData.acceleration;\n            NSLog(@\"x = %f y = %f z = %f\", acceleration.x, acceleration.y , acceleration.z);\n        }];\n    }else\n    {\n        NSLog(@\"加速计不可用\");\n    }\n}\n\n\n\n\n\n@end\n\n```\n","source":"_posts/IOS-CoreMotion.md","raw":"title: IOS-CoreMotion\ndate: 2015-08-24 09:04:52\ntags: IOS\n\n---\n```\n#import \"ViewController.h\"\n#import <CoreMotion/CoreMotion.h>\n\n@interface ViewController ()\n@property (nonatomic, strong) CMMotionManager *mgr;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 1.创建coreMotion管理者\n    self.mgr = [[CMMotionManager alloc] init];\n    \n     if (self.mgr.isAccelerometerAvailable) {\n          // 3.开始采样\n         [self.mgr startAccelerometerUpdates]; // pull\n     }else\n     {\n         NSLog(@\"加速计不可用\");\n     }\n\n}\n\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    CMAcceleration acceleration = self.mgr.accelerometerData.acceleration;\n    \n     NSLog(@\"x = %f y = %f z = %f\", acceleration.x, acceleration.y , acceleration.z);\n}\n\n- (void)push\n{\n    // 1.创建coreMotion管理者\n    //    CMMotionManager *mgr = [[CMMotionManager alloc] init];\n    self.mgr = [[CMMotionManager alloc] init];\n    \n    // 2.判断加速计是否可用\n    if (self.mgr.isAccelerometerAvailable) {\n        /*\n         isAccelerometerActive 是否正在采集\n         accelerometerData 采集到得数据\n         startAccelerometerUpdates  pull\n         startAccelerometerUpdatesToQueue  push\n         stopAccelerometerUpdates 停止采集\n         accelerometerUpdateInterval 采样时间\n         */\n        // 3.设置采样时间\n        self.mgr.accelerometerUpdateInterval = 1 / 30.0;\n        // 4.开始采样\n        \n        [self.mgr startAccelerometerUpdatesToQueue:[NSOperationQueue mainQueue] withHandler:^(CMAccelerometerData *accelerometerData, NSError *error) {\n            // 这个block是采集到数据时就会调用\n            if (error) return ;\n            CMAcceleration acceleration = accelerometerData.acceleration;\n            NSLog(@\"x = %f y = %f z = %f\", acceleration.x, acceleration.y , acceleration.z);\n        }];\n    }else\n    {\n        NSLog(@\"加速计不可用\");\n    }\n}\n\n\n\n\n\n@end\n\n```\n","slug":"IOS-CoreMotion","published":1,"updated":"2015-08-24T01:05:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq5h0000ovfy4qy5ri8k"},{"title":"隐藏UInavigationBar下的黑边","date":"2015-08-19T08:55:22.000Z","type":"tags","_content":"本文参考[StackOverFlow](http://stackoverflow.com/questions/19226965/how-to-hide-ios7-uinavigationbar-1px-bottom-line)\n### 在基类中\n```\n   UINavigationBar *navigationBar = self.navigationController.navigationBar;\n    [navigationBar setBackgroundImage:[UIImage imageWithColor:KTHEME_COLOR size:CGSizeMake(SCREEN_WIDTH, 1)]\n                       forBarPosition:UIBarPositionAny\n                           barMetrics:UIBarMetricsDefault];\n    [navigationBar setShadowImage:[UIImage new]];\n    \n```\nimageWithColor 是一个分类在前边文章中出现过","source":"_posts/隐藏UInavigationBar下的黑边.md","raw":"title: 隐藏UInavigationBar下的黑边\ndate: 2015-08-19 16:55:22\ntype: \"tags\"\ntags: 实用小工具\n\n---\n本文参考[StackOverFlow](http://stackoverflow.com/questions/19226965/how-to-hide-ios7-uinavigationbar-1px-bottom-line)\n### 在基类中\n```\n   UINavigationBar *navigationBar = self.navigationController.navigationBar;\n    [navigationBar setBackgroundImage:[UIImage imageWithColor:KTHEME_COLOR size:CGSizeMake(SCREEN_WIDTH, 1)]\n                       forBarPosition:UIBarPositionAny\n                           barMetrics:UIBarMetricsDefault];\n    [navigationBar setShadowImage:[UIImage new]];\n    \n```\nimageWithColor 是一个分类在前边文章中出现过","slug":"隐藏UInavigationBar下的黑边","published":1,"updated":"2015-08-19T08:59:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq850006ovfyna8vokp3"},{"title":"蓝牙设备","date":"2015-08-24T00:53:00.000Z","_content":"## 蓝牙设备的基本使用代码\n\n```\n#import \"ViewController.h\"\n#include <GameKit/GameKit.h>\n\n@interface ViewController ()<UINavigationControllerDelegate, UIImagePickerControllerDelegate, GKPeerPickerControllerDelegate>\n/**\n *  连接\n */\n- (IBAction)connect;\n/**\n *  选择图片\n */\n- (IBAction)selectedPhoto;\n/**\n *  发送\n */\n- (IBAction)send;\n\n@property (weak, nonatomic) IBOutlet UIImageView *customIV;\n/**\n *  会话\n */\n@property (nonatomic, strong) GKSession *session;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n}\n\n\n- (IBAction)connect {\n    \n    // 1.创建选择其他蓝牙设备的控制器\n    GKPeerPickerController *peerPk = [[GKPeerPickerController alloc] init];\n    // 2.成为该控制器的代理\n    peerPk.delegate = self;\n    // 3.显示蓝牙控制器\n    [peerPk show];\n}\n#pragma mark - GKPeerPickerControllerDelegate\n// 4.实现dialing方法\n/**\n *  当蓝牙设备连接成功就会调用\n *\n *  @param picker  触发时间的控制器\n *  @param peerID  连接蓝牙设备的ID\n *  @param session 连接蓝牙的会话(可用通讯), 以后只要拿到session就可以传输数据\n */\n- (void)peerPickerController:(GKPeerPickerController *)picker didConnectPeer:(NSString *)peerID toSession:(GKSession *)session\n{\n    NSLog(@\"%@\", peerID);\n    // 1.保存会话\n    self.session = session;\n    \n    // 2.设置监听接收传递过来的数据\n    /*\n     Handler: 谁来处理接收到得数据\n     withContext: 传递数据\n     */\n    [self.session setDataReceiveHandler:self withContext:nil];\n    \n    \n    // 2.关闭显示蓝牙设备控制器\n    [picker dismiss];\n}\n/**\n *  接收到其它设备传递过来的数据就会调用\n *\n *  @param data    传递过来的数据\n *  @param peer    传递数据设备的ID\n *  @param session 会话\n *  @param context 注册监听时传递的数据\n */\n- (void) receiveData:(NSData *)data fromPeer:(NSString *)peer inSession: (GKSession *)session context:(void *)context\n{\n//    NSLog(@\"%s\", __func__);\n    // 1.将传递过来的数据转换为图片(注意: 因为发送的时图片, 所以才需要转换为图片)\n    UIImage *image = [UIImage imageWithData:data];\n    self.customIV.image = image;\n}\n\n\n- (void)peerPickerControllerDidCancel:(GKPeerPickerController *)picker\n{\n    \n}\n\n\n- (IBAction)send {\n    // 利用session发送图片数据即可\n    // 1.取出customImageView上得图片, 转换为二进制\n    UIImage *image =  self.customIV.image;\n    NSData *data = UIImagePNGRepresentation(image);\n    \n    /*\n     GKSendDataReliable, 数据安全的发送模式, 慢\n     GKSendDataUnreliable, 数据不安全的发送模式, 快\n     */\n    \n    /*\n     data: 需要发送的数据\n     DataReliable: 是否安全的发送数据(发送数据的模式)\n     error: 是否监听发送错误\n     */\n    [self.session sendDataToAllPeers:data withDataMode:GKSendDataReliable error:nil];\n}\n\n\n- (IBAction)selectedPhoto\n{\n    \n    // 1.创建图片选择控制器\n    UIImagePickerController *imagePk = [[UIImagePickerController alloc] init];\n    // 2.判断图库是否可用打开\n    if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeSavedPhotosAlbum])\n    {\n        // 3.设置打开图库的类型\n        imagePk.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;\n        \n        imagePk.delegate = self;\n        \n        // 4.打开图片选择控制器\n        [self presentViewController:imagePk animated:YES completion:nil];\n    }\n}\n#pragma mark - UIImagePickerControllerDelegate\n- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info\n{\n//    NSLog(@\"%@\", info);\n    self.customIV.image = info[UIImagePickerControllerOriginalImage];\n    \n    [picker dismissViewControllerAnimated:YES completion:nil];\n}\n\n@end\n\n\n```\n\n##CoreBluetooth\n\n```\n\n#import \"ViewController.h\"\n#import <CoreBluetooth/CoreBluetooth.h>\n\n@interface ViewController ()<CBCentralManagerDelegate, CBPeripheralDelegate>\n/**\n *  外设\n */\n@property (nonatomic, strong) NSMutableArray *peripherals;\n/**\n *  中心管理者\n */\n@property (nonatomic, strong) CBCentralManager *mgr;\n@end\n\n@implementation ViewController\n\n- (NSMutableArray *)peripherals\n{\n    if (!_peripherals) {\n        _peripherals = [NSMutableArray array];\n    }\n    return _peripherals;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    // 1.创建中心设备\n    CBCentralManager *mgr = [[CBCentralManager alloc] init];\n    self.mgr = mgr;\n    \n    \n    // 设置代理\n    mgr.delegate = self;\n    \n    // 2.利用中心设备扫描外部设备\n    /*\n     如果指定数组代表只扫描指定的设备\n     */\n    [mgr scanForPeripheralsWithServices:nil options:nil];\n}\n#pragma mark - CBCentralManagerDelegate\n- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI\n{\n\n    // 保存扫描到得外部设备\n    // 判断如果数组中不包含当前扫描到得外部设置才保存\n    if (![self.peripherals containsObject:peripheral]) {\n        \n        peripheral.delegate = self;\n        [self.peripherals addObject:peripheral];\n    }\n}\n\n/**\n *  模拟点击, 然后连接所有的外设\n */\n- (void)start\n{\n    for (CBPeripheral *peripheral in self.peripherals) {\n        /**\n         *  连接外设\n         */\n        [self.mgr connectPeripheral:peripheral options:nil];\n    }\n}\n/**\n *  连接外设成功调用\n */\n- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral\n{\n    // 扫描外设中得服务\n    [peripheral discoverServices:nil];\n}\n/**\n *  连接外设失败调用\n */\n- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error\n{\n    \n}\n\n#pragma makr - CBPeripheralDelegate\n/**\n *  只要扫描到服务就会调用\n *\n *  @param peripheral 服务所在的外设\n */\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error\n{\n    \n    // 获取外设中所有扫描到得服务\n    NSArray *services = peripheral.services;\n    for (CBService *service in services) {\n        // 拿到需要的服务\n        if ([service.UUID.UUIDString isEqualToString:@\"123\"])\n        {\n            // 从需要的服务中查找需要的特征\n            // 从peripheral中得service中扫描特征\n            [peripheral discoverCharacteristics:nil forService:service];\n        }\n    }\n}\n\n/**\n *  只要扫描到特征就会调用\n *\n *  @param peripheral 特征所属的外设\n *  @param service    特征所属的服务\n */\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error\n{\n    \n    // 拿到服务中所有的特诊\n    NSArray *characteristics =  service.characteristics;\n    // 遍历特征, 拿到需要的特征处理\n    for (CBCharacteristic * characteristic in characteristics) {\n        if ([characteristic.UUID.UUIDString isEqualToString:@\"8888\"]) {\n            NSLog(@\"设置闹钟\");\n\n        }\n    }\n}\n@end\n\n```","source":"_posts/蓝牙设备.md","raw":"title: 蓝牙设备\ndate: 2015-08-24 08:53:00\ntags: IOS\n\n---\n## 蓝牙设备的基本使用代码\n\n```\n#import \"ViewController.h\"\n#include <GameKit/GameKit.h>\n\n@interface ViewController ()<UINavigationControllerDelegate, UIImagePickerControllerDelegate, GKPeerPickerControllerDelegate>\n/**\n *  连接\n */\n- (IBAction)connect;\n/**\n *  选择图片\n */\n- (IBAction)selectedPhoto;\n/**\n *  发送\n */\n- (IBAction)send;\n\n@property (weak, nonatomic) IBOutlet UIImageView *customIV;\n/**\n *  会话\n */\n@property (nonatomic, strong) GKSession *session;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n}\n\n\n- (IBAction)connect {\n    \n    // 1.创建选择其他蓝牙设备的控制器\n    GKPeerPickerController *peerPk = [[GKPeerPickerController alloc] init];\n    // 2.成为该控制器的代理\n    peerPk.delegate = self;\n    // 3.显示蓝牙控制器\n    [peerPk show];\n}\n#pragma mark - GKPeerPickerControllerDelegate\n// 4.实现dialing方法\n/**\n *  当蓝牙设备连接成功就会调用\n *\n *  @param picker  触发时间的控制器\n *  @param peerID  连接蓝牙设备的ID\n *  @param session 连接蓝牙的会话(可用通讯), 以后只要拿到session就可以传输数据\n */\n- (void)peerPickerController:(GKPeerPickerController *)picker didConnectPeer:(NSString *)peerID toSession:(GKSession *)session\n{\n    NSLog(@\"%@\", peerID);\n    // 1.保存会话\n    self.session = session;\n    \n    // 2.设置监听接收传递过来的数据\n    /*\n     Handler: 谁来处理接收到得数据\n     withContext: 传递数据\n     */\n    [self.session setDataReceiveHandler:self withContext:nil];\n    \n    \n    // 2.关闭显示蓝牙设备控制器\n    [picker dismiss];\n}\n/**\n *  接收到其它设备传递过来的数据就会调用\n *\n *  @param data    传递过来的数据\n *  @param peer    传递数据设备的ID\n *  @param session 会话\n *  @param context 注册监听时传递的数据\n */\n- (void) receiveData:(NSData *)data fromPeer:(NSString *)peer inSession: (GKSession *)session context:(void *)context\n{\n//    NSLog(@\"%s\", __func__);\n    // 1.将传递过来的数据转换为图片(注意: 因为发送的时图片, 所以才需要转换为图片)\n    UIImage *image = [UIImage imageWithData:data];\n    self.customIV.image = image;\n}\n\n\n- (void)peerPickerControllerDidCancel:(GKPeerPickerController *)picker\n{\n    \n}\n\n\n- (IBAction)send {\n    // 利用session发送图片数据即可\n    // 1.取出customImageView上得图片, 转换为二进制\n    UIImage *image =  self.customIV.image;\n    NSData *data = UIImagePNGRepresentation(image);\n    \n    /*\n     GKSendDataReliable, 数据安全的发送模式, 慢\n     GKSendDataUnreliable, 数据不安全的发送模式, 快\n     */\n    \n    /*\n     data: 需要发送的数据\n     DataReliable: 是否安全的发送数据(发送数据的模式)\n     error: 是否监听发送错误\n     */\n    [self.session sendDataToAllPeers:data withDataMode:GKSendDataReliable error:nil];\n}\n\n\n- (IBAction)selectedPhoto\n{\n    \n    // 1.创建图片选择控制器\n    UIImagePickerController *imagePk = [[UIImagePickerController alloc] init];\n    // 2.判断图库是否可用打开\n    if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeSavedPhotosAlbum])\n    {\n        // 3.设置打开图库的类型\n        imagePk.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;\n        \n        imagePk.delegate = self;\n        \n        // 4.打开图片选择控制器\n        [self presentViewController:imagePk animated:YES completion:nil];\n    }\n}\n#pragma mark - UIImagePickerControllerDelegate\n- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info\n{\n//    NSLog(@\"%@\", info);\n    self.customIV.image = info[UIImagePickerControllerOriginalImage];\n    \n    [picker dismissViewControllerAnimated:YES completion:nil];\n}\n\n@end\n\n\n```\n\n##CoreBluetooth\n\n```\n\n#import \"ViewController.h\"\n#import <CoreBluetooth/CoreBluetooth.h>\n\n@interface ViewController ()<CBCentralManagerDelegate, CBPeripheralDelegate>\n/**\n *  外设\n */\n@property (nonatomic, strong) NSMutableArray *peripherals;\n/**\n *  中心管理者\n */\n@property (nonatomic, strong) CBCentralManager *mgr;\n@end\n\n@implementation ViewController\n\n- (NSMutableArray *)peripherals\n{\n    if (!_peripherals) {\n        _peripherals = [NSMutableArray array];\n    }\n    return _peripherals;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    // 1.创建中心设备\n    CBCentralManager *mgr = [[CBCentralManager alloc] init];\n    self.mgr = mgr;\n    \n    \n    // 设置代理\n    mgr.delegate = self;\n    \n    // 2.利用中心设备扫描外部设备\n    /*\n     如果指定数组代表只扫描指定的设备\n     */\n    [mgr scanForPeripheralsWithServices:nil options:nil];\n}\n#pragma mark - CBCentralManagerDelegate\n- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI\n{\n\n    // 保存扫描到得外部设备\n    // 判断如果数组中不包含当前扫描到得外部设置才保存\n    if (![self.peripherals containsObject:peripheral]) {\n        \n        peripheral.delegate = self;\n        [self.peripherals addObject:peripheral];\n    }\n}\n\n/**\n *  模拟点击, 然后连接所有的外设\n */\n- (void)start\n{\n    for (CBPeripheral *peripheral in self.peripherals) {\n        /**\n         *  连接外设\n         */\n        [self.mgr connectPeripheral:peripheral options:nil];\n    }\n}\n/**\n *  连接外设成功调用\n */\n- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral\n{\n    // 扫描外设中得服务\n    [peripheral discoverServices:nil];\n}\n/**\n *  连接外设失败调用\n */\n- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error\n{\n    \n}\n\n#pragma makr - CBPeripheralDelegate\n/**\n *  只要扫描到服务就会调用\n *\n *  @param peripheral 服务所在的外设\n */\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error\n{\n    \n    // 获取外设中所有扫描到得服务\n    NSArray *services = peripheral.services;\n    for (CBService *service in services) {\n        // 拿到需要的服务\n        if ([service.UUID.UUIDString isEqualToString:@\"123\"])\n        {\n            // 从需要的服务中查找需要的特征\n            // 从peripheral中得service中扫描特征\n            [peripheral discoverCharacteristics:nil forService:service];\n        }\n    }\n}\n\n/**\n *  只要扫描到特征就会调用\n *\n *  @param peripheral 特征所属的外设\n *  @param service    特征所属的服务\n */\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error\n{\n    \n    // 拿到服务中所有的特诊\n    NSArray *characteristics =  service.characteristics;\n    // 遍历特征, 拿到需要的特征处理\n    for (CBCharacteristic * characteristic in characteristics) {\n        if ([characteristic.UUID.UUIDString isEqualToString:@\"8888\"]) {\n            NSLog(@\"设置闹钟\");\n\n        }\n    }\n}\n@end\n\n```","slug":"蓝牙设备","published":1,"updated":"2015-08-24T00:57:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq870009ovfyj1yd0ofx"},{"title":"深入理解Objective-C:Category","date":"2015-08-18T09:31:12.000Z","type":"tags","_content":"本篇转载于:[美团技术博客](http://tech.meituan.com/DiveIntoCategory.html) \n## 摘要\n无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。\n## 简介\n本文系学习Objective-C的runtime源码时整理所成，主要剖析了category在runtime层的实现原理以及和category相关的方方面面，内容包括：\n\n* 初入宝地-category简介\n* 连类比事-category和extension\n* 挑灯细览-category真面目\n* 追本溯源-category如何加载\n* 旁枝末叶-category和+load方法\n* 触类旁通-category和方法覆盖\n* 更上一层-category和关联对象\n\n### 1、初入宝地-category简介\ncategory是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景1\n\n* 可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。\n* 声明私有方法\n不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：\n\n* 模拟多继承\n* 把framework的私有方法公开\n\nObjective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。\n### 2、连类比事-category和extension\nextension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见2）\n\n但是category则完全不一样，它是在运行期决议的。\n就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。\n## 3、挑灯细览-category真面目\n我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了\n1)、类的名字（name）\n2)、类（cls）\n3)、category中所有给类添加的实例方法的列表（instanceMethods）\n4)、category中所有添加的类方法的列表（classMethods）\n5)、category实现的所有协议的列表（protocols）\n6)、category中添加的所有属性（instanceProperties）\n\n```\ntypedef struct category_t {\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n} category_t;\n```\n从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。\nok，我们先去写一个category看一下category到底为何物：\n**MyClass.h：\n**\n\n```\n#import <Foundation/Foundation.h>\n\n@interface MyClass : NSObject\n\n- (void)printName;\n\n@end\n\n@interface MyClass(MyAddition)\n\n@property(nonatomic, copy) NSString *name;\n\n- (void)printName;\n\n@end\n```\n**MyClass.m：\n**\n\n```\n#import \"MyClass.h\"\n\n@implementation MyClass\n\n- (void)printName\n{\n    NSLog(@\"%@\",@\"MyClass\");\n}\n\n@end\n\n@implementation MyClass(MyAddition)\n\n- (void)printName\n{\n    NSLog(@\"%@\",@\"MyAddition\");\n}\n\n@end\n```\n我们使用clang的命令去看看category到底会变成什么：\n\n```\nclang -rewrite-objc MyClass.m\n```\n好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：\n\n```\nstatic struct /*_method_list_t*/ {\nunsigned int entsize;  // sizeof(struct _objc_method)\nunsigned int method_count;\nstruct _objc_method method_list[1];\n} _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\nsizeof(_objc_method),\n1,\n{{(struct objc_selector *)\"printName\", \"v16@0:8\", (void *)_I_MyClass_MyAddition_printName}}\n};\n\nstatic struct /*_prop_list_t*/ {\nunsigned int entsize;  // sizeof(struct _prop_t)\nunsigned int count_of_properties;\nstruct _prop_t prop_list[1];\n} _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\nsizeof(_prop_t),\n1,\n{{\"name\",\"T@\\\"NSString\\\",C,N\"}}\n};\n\nextern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;\n\nstatic struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) =\n{\n\"MyClass\",\n0, // &OBJC_CLASS_$_MyClass,\n(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,\n0,\n0,\n(const struct _prop_list_t *)&_OBJC_$_PROP_LIST_MyClass_$_MyAddition,\n};\nstatic void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) {\n_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &OBJC_CLASS_$_MyClass;\n}\n#pragma section(\".objc_inithooks$B\", long, read, write)\n__declspec(allocate(\".objc_inithooks$B\")) static void *OBJC_CATEGORY_SETUP[] = {\n(void *)&OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,\n};\nstatic struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (\"__DATA, __objc_classlist,regular,no_dead_strip\")))= {\n&OBJC_CLASS_$_MyClass,\n};\nstatic struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = {\n&OBJC_CLASS_$_MyClass,\n};\nstatic struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= {\n&_OBJC_$_CATEGORY_MyClass_$_MyAddition,\n};\n```\n我们可以看到:\n\n* 1)、首先编译器生成了实例方法列表OBJC$CATEGORY_INSTANCE_METHODS_MyClass$MyAddition和属性列表_OBJC$PROP_LIST_MyClass$MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。\n* 2)、其次，编译器生成了category本身_OBJC$CATEGORY_MyClass$MyAddition，并用前面生成的列表来初始化category本身。\n* 3)、最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABEL_CATEGORY$（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。\n\n到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。\n## 4、追本溯源-category如何加载\n我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。\n想了解更多dyld地同学可以移步这里[（3）](https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html)。\n对于OC运行时，入口方法如下（在objc-os.mm文件中）：\n\n```\nvoid _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n\n    // fixme defer initialization until an objc-using image is found?\n    environ_init();\n    tls_init();\n    lock_init();\n    exception_init();\n\n    // Register for unmap first, in case some +load unmaps something\n    _dyld_register_func_for_remove_image(&unmap_image);\n    dyld_register_image_state_change_handler(dyld_image_state_bound,\n                                             1/*batch*/, &map_images);\n    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &load_images);\n}\n```\ncategory被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：\n\n```\n// Discover categories. \n    for (EACH_HEADER) {\n        category_t **catlist =\n            _getObjc2CategoryList(hi, &count);\n        for (i = 0; i < count; i++) {\n            category_t *cat = catlist[i];\n            class_t *cls = remapClass(cat->cls);\n\n            if (!cls) {\n                // Category's target class is missing (probably weak-linked).\n                // Disavow any knowledge of this category.\n                catlist[i] = NULL;\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \"\n                                 \"missing weak-linked target class\",\n                                 cat->name, cat);\n                }\n                continue;\n            }\n\n            // Process this category. \n            // First, register the category with its target class. \n            // Then, rebuild the class's method lists (etc) if \n            // the class is realized. \n            BOOL classExists = NO;\n            if (cat->instanceMethods ||  cat->protocols \n                ||  cat->instanceProperties)\n            {\n                addUnattachedCategoryForClass(cat, cls, hi);\n                if (isRealized(cls)) {\n                    remethodizeClass(cls);\n                    classExists = YES;\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category -%s(%s) %s\",\n                                 getName(cls), cat->name,\n                                 classExists ? \"on existing class\" : \"\");\n                }\n            }\n\n            if (cat->classMethods  ||  cat->protocols \n                /* ||  cat->classProperties */)\n            {\n                addUnattachedCategoryForClass(cat, cls->isa, hi);\n                if (isRealized(cls->isa)) {\n                    remethodizeClass(cls->isa);\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category +%s(%s)\",\n                                 getName(cls), cat->name);\n                }\n            }\n        }\n    }\n```\n首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。\n略去PrintConnecting这个用于log的东西，这段代码很容易理解：\n1)、把category的实例方法、协议以及属性添加到类上\n2)、把category的类方法和协议添加到类的metaclass上\n\n值得注意的是，在代码中有一小段注释 / || cat->classProperties /，看来苹果有过给类添加属性的计划啊。\nok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：\n在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。\n\n```\nstatic void remethodizeClass(class_t *cls)\n{\n    category_list *cats;\n    BOOL isMeta;\n\n    rwlock_assert_writing(&runtimeLock);\n\n    isMeta = isMetaClass(cls);\n\n    // Re-methodizing: check for more categories\n    if ((cats = unattachedCategoriesForClass(cls))) {\n        chained_property_list *newproperties;\n        const protocol_list_t **newprotos;\n\n        if (PrintConnecting) {\n            _objc_inform(\"CLASS: attaching categories to class '%s' %s\",\n                         getName(cls), isMeta ? \"(meta)\" : \"\");\n        }\n\n        // Update methods, properties, protocols\n\n        BOOL vtableAffected = NO;\n        attachCategoryMethods(cls, cats, &vtableAffected);\n\n        newproperties = buildPropertyList(NULL, cats, isMeta);\n        if (newproperties) {\n            newproperties->next = cls->data()->properties;\n            cls->data()->properties = newproperties;\n        }\n\n        newprotos = buildProtocolList(cats, NULL, cls->data()->protocols);\n        if (cls->data()->protocols  &&  cls->data()->protocols != newprotos) {\n            _free_internal(cls->data()->protocols);\n        }\n        cls->data()->protocols = newprotos;\n\n        _free_internal(cats);\n\n        // Update method caches and vtables\n        flushCaches(cls);\n        if (vtableAffected) flushVtables(cls);\n    }\n}\n```\n而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods：\n\n```\nstatic void \nattachCategoryMethods(class_t *cls, category_list *cats,\n                      BOOL *inoutVtablesAffected)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    BOOL isMeta = isMetaClass(cls);\n    method_list_t **mlists = (method_list_t **)\n        _malloc_internal(cats->count * sizeof(*mlists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    BOOL fromBundle = NO;\n    while (i--) {\n        method_list_t *mlist = cat_method_list(cats->list[i].cat, isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= cats->list[i].fromBundle;\n        }\n    }\n\n    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);\n\n    _free_internal(mlists);\n\n}\n```\nattachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段：\n\n```\nfor (uint32_t m = 0;\n             (scanForCustomRR || scanForCustomAWZ)  &&  m < mlist->count;\n             m++)\n        {\n            SEL sel = method_list_nth(mlist, m)->name;\n            if (scanForCustomRR  &&  isRRSelector(sel)) {\n                cls->setHasCustomRR();\n                scanForCustomRR = false;\n            } else if (scanForCustomAWZ  &&  isAWZSelector(sel)) {\n                cls->setHasCustomAWZ();\n                scanForCustomAWZ = false;\n            }\n        }\n\n        // Fill method list array\n        newLists[newCount++] = mlist;\n    .\n    .\n    .\n\n    // Copy old methods to the method list array\n    for (i = 0; i < oldCount; i++) {\n        newLists[newCount++] = oldLists[i];\n    }\n```\n需要注意的有两点：\n1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA\n2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。\n### 5、旁枝末叶-category和+load方法\n我们知道，在类和category中都可以有+load方法，那么有两个问题：\n1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？\n2)、这么些个+load方法，调用顺序是咋样的呢？\n鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：\n![image](http://tech.meituan.com/img/diveintocategory/project.png)\n我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。\n在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:\n![image](http://tech.meituan.com/img/diveintocategory/environment_vars.png)\n运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：\n\nobjc[1187]: REPLACED: -[MyClass printName] by category Category1\nobjc[1187]: REPLACED: -[MyClass printName] by category Category2\n.\n.\n.\nobjc[1187]: LOAD: class 'MyClass' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category1)' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category2)' scheduled for +load\nobjc[1187]: LOAD: +[MyClass load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category1) load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category2) load]\n\n所以，对于上面两个问题，答案是很明显的：\n1)、可以调用，因为附加category到类的工作会先于+load方法的执行\n2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。\n目前的编译顺序是这样的：\n![image](http://tech.meituan.com/img/diveintocategory/compile1.png)\n我们调整一个Category1和Category2的编译顺序，run。ok，我们可以看到控制台的输出顺序变了：\n![image](http://tech.meituan.com/img/diveintocategory/compile2.png)\nobjc[1187]: REPLACED: -[MyClass printName] by category Category2\nobjc[1187]: REPLACED: -[MyClass printName] by category Category1\n.\n.\n.\nobjc[1187]: LOAD: class 'MyClass' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category2)' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category1)' scheduled for +load\nobjc[1187]: LOAD: +[MyClass load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category2) load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category1) load]\n\n虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。\n这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。\n## 6、触类旁通-category和方法覆盖\n鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:\n怎么调用到原来类中被category覆盖掉的方法？\n对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：\n\n```\nClass currentClass = [MyClass class];\nMyClass *my = [[MyClass alloc] init];\n\nif (currentClass) {\n    unsigned int methodCount;\n    Method *methodList = class_copyMethodList(currentClass, &methodCount);\n    IMP lastImp = NULL;\n    SEL lastSel = NULL;\n    for (NSInteger i = 0; i < methodCount; i++) {\n        Method method = methodList[i];\n        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) \n                                        encoding:NSUTF8StringEncoding];\n        if ([@\"printName\" isEqualToString:methodName]) {\n            lastImp = method_getImplementation(method);\n            lastSel = method_getName(method);\n        }\n    }\n    typedef void (*fn)(id,SEL);\n\n    if (lastImp != NULL) {\n        fn f = (fn)lastImp;\n        f(my,lastSel);\n    }\n    free(methodList);\n}\n```\n## 7、更上一层-category和关联对象\n如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。\n**MyClass+Category1.h:\n**\n\n```\n#import \"MyClass.h\"\n\n@interface MyClass (Category1)\n\n@property(nonatomic,copy) NSString *name;\n\n@end\n```\n**MyClass+Category1.m:\n**\n\n```\n#import \"MyClass+Category1.h\"\n#import <objc/runtime.h>\n\n@implementation MyClass (Category1)\n\n+ (void)load\n{\n    NSLog(@\"%@\",@\"load in Category1\");\n}\n\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self,\n                             \"name\",\n                             name,\n                             OBJC_ASSOCIATION_COPY);\n}\n\n- (NSString*)name\n{\n    NSString *nameObject = objc_getAssociatedObject(self, \"name\");\n    return nameObject;\n}\n\n@end\n```\n但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？\n我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：\n\n```\nvoid _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {\n    // retain the new value (if any) outside the lock.\n    ObjcAssociation old_association(0, nil);\n    id new_value = value ? acquireValue(value, policy) : nil;\n    {\n        AssociationsManager manager;\n        AssociationsHashMap &associations(manager.associations());\n        disguised_ptr_t disguised_object = DISGUISE(object);\n        if (new_value) {\n            // break any existing association.\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i != associations.end()) {\n                // secondary table exists\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    j->second = ObjcAssociation(policy, new_value);\n                } else {\n                    (*refs)[key] = ObjcAssociation(policy, new_value);\n                }\n            } else {\n                // create the new association (first time).\n                ObjectAssociationMap *refs = new ObjectAssociationMap;\n                associations[disguised_object] = refs;\n                (*refs)[key] = ObjcAssociation(policy, new_value);\n                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));\n            }\n        } else {\n            // setting the association to nil breaks the association.\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i !=  associations.end()) {\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    refs->erase(j);\n                }\n            }\n        }\n    }\n    // release the old value (outside of the lock).\n    if (old_association.hasValue()) ReleaseValue()(old_association);\n}\n```\n我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：\n\n```\nclass AssociationsManager {\n    static OSSpinLock _lock;\n    static AssociationsHashMap *_map;               // associative references:  object pointer -> PtrPtrHashMap.\npublic:\n    AssociationsManager()   { OSSpinLockLock(&_lock); }\n    ~AssociationsManager()  { OSSpinLockUnlock(&_lock); }\n\n    AssociationsHashMap &associations() {\n        if (_map == NULL)\n            _map = new AssociationsHashMap();\n        return *_map;\n    }\n};\n```\nAssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。\n而在对象的销毁逻辑里面，见objc-runtime-new.mm:\n\n```\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        Class isa_gen = _object_getClass(obj);\n        class_t *isa = newcls(isa_gen);\n\n        // Read all of the flags at once for performance.\n        bool cxx = hasCxxStructors(isa);\n        bool assoc = !UseGC && _class_instancesHaveAssociatedObjects(isa_gen);\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n\n        if (!UseGC) objc_clear_deallocating(obj);\n    }\n\n    return obj;\n}\n```\n嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。\n## 后记\n正如侯捷先生所讲-“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的(在[http://www.opensource.apple.com/tarballs/](http://www.opensource.apple.com/tarballs/)可以下载到全部的开源代码)。\n本系列runtime源码学习将会持续更新，意犹未尽的同学可以自行到上述网站下载源码学习。行笔简陋，如有错误，望指正。\n\n\n\n\n\n\n\n","source":"_posts/深入理解Objective-C：Category.md","raw":"title: 深入理解Objective-C:Category\ndate: 2015-08-18 17:31:12\ntype: \"tags\"\ntags: Objective-C\n\n---\n本篇转载于:[美团技术博客](http://tech.meituan.com/DiveIntoCategory.html) \n## 摘要\n无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。\n## 简介\n本文系学习Objective-C的runtime源码时整理所成，主要剖析了category在runtime层的实现原理以及和category相关的方方面面，内容包括：\n\n* 初入宝地-category简介\n* 连类比事-category和extension\n* 挑灯细览-category真面目\n* 追本溯源-category如何加载\n* 旁枝末叶-category和+load方法\n* 触类旁通-category和方法覆盖\n* 更上一层-category和关联对象\n\n### 1、初入宝地-category简介\ncategory是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景1\n\n* 可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。\n* 声明私有方法\n不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：\n\n* 模拟多继承\n* 把framework的私有方法公开\n\nObjective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。\n### 2、连类比事-category和extension\nextension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见2）\n\n但是category则完全不一样，它是在运行期决议的。\n就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。\n## 3、挑灯细览-category真面目\n我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了\n1)、类的名字（name）\n2)、类（cls）\n3)、category中所有给类添加的实例方法的列表（instanceMethods）\n4)、category中所有添加的类方法的列表（classMethods）\n5)、category实现的所有协议的列表（protocols）\n6)、category中添加的所有属性（instanceProperties）\n\n```\ntypedef struct category_t {\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n} category_t;\n```\n从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。\nok，我们先去写一个category看一下category到底为何物：\n**MyClass.h：\n**\n\n```\n#import <Foundation/Foundation.h>\n\n@interface MyClass : NSObject\n\n- (void)printName;\n\n@end\n\n@interface MyClass(MyAddition)\n\n@property(nonatomic, copy) NSString *name;\n\n- (void)printName;\n\n@end\n```\n**MyClass.m：\n**\n\n```\n#import \"MyClass.h\"\n\n@implementation MyClass\n\n- (void)printName\n{\n    NSLog(@\"%@\",@\"MyClass\");\n}\n\n@end\n\n@implementation MyClass(MyAddition)\n\n- (void)printName\n{\n    NSLog(@\"%@\",@\"MyAddition\");\n}\n\n@end\n```\n我们使用clang的命令去看看category到底会变成什么：\n\n```\nclang -rewrite-objc MyClass.m\n```\n好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：\n\n```\nstatic struct /*_method_list_t*/ {\nunsigned int entsize;  // sizeof(struct _objc_method)\nunsigned int method_count;\nstruct _objc_method method_list[1];\n} _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\nsizeof(_objc_method),\n1,\n{{(struct objc_selector *)\"printName\", \"v16@0:8\", (void *)_I_MyClass_MyAddition_printName}}\n};\n\nstatic struct /*_prop_list_t*/ {\nunsigned int entsize;  // sizeof(struct _prop_t)\nunsigned int count_of_properties;\nstruct _prop_t prop_list[1];\n} _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\nsizeof(_prop_t),\n1,\n{{\"name\",\"T@\\\"NSString\\\",C,N\"}}\n};\n\nextern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;\n\nstatic struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) =\n{\n\"MyClass\",\n0, // &OBJC_CLASS_$_MyClass,\n(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,\n0,\n0,\n(const struct _prop_list_t *)&_OBJC_$_PROP_LIST_MyClass_$_MyAddition,\n};\nstatic void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) {\n_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &OBJC_CLASS_$_MyClass;\n}\n#pragma section(\".objc_inithooks$B\", long, read, write)\n__declspec(allocate(\".objc_inithooks$B\")) static void *OBJC_CATEGORY_SETUP[] = {\n(void *)&OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,\n};\nstatic struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (\"__DATA, __objc_classlist,regular,no_dead_strip\")))= {\n&OBJC_CLASS_$_MyClass,\n};\nstatic struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = {\n&OBJC_CLASS_$_MyClass,\n};\nstatic struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= {\n&_OBJC_$_CATEGORY_MyClass_$_MyAddition,\n};\n```\n我们可以看到:\n\n* 1)、首先编译器生成了实例方法列表OBJC$CATEGORY_INSTANCE_METHODS_MyClass$MyAddition和属性列表_OBJC$PROP_LIST_MyClass$MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。\n* 2)、其次，编译器生成了category本身_OBJC$CATEGORY_MyClass$MyAddition，并用前面生成的列表来初始化category本身。\n* 3)、最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABEL_CATEGORY$（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。\n\n到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。\n## 4、追本溯源-category如何加载\n我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。\n想了解更多dyld地同学可以移步这里[（3）](https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html)。\n对于OC运行时，入口方法如下（在objc-os.mm文件中）：\n\n```\nvoid _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n\n    // fixme defer initialization until an objc-using image is found?\n    environ_init();\n    tls_init();\n    lock_init();\n    exception_init();\n\n    // Register for unmap first, in case some +load unmaps something\n    _dyld_register_func_for_remove_image(&unmap_image);\n    dyld_register_image_state_change_handler(dyld_image_state_bound,\n                                             1/*batch*/, &map_images);\n    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &load_images);\n}\n```\ncategory被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：\n\n```\n// Discover categories. \n    for (EACH_HEADER) {\n        category_t **catlist =\n            _getObjc2CategoryList(hi, &count);\n        for (i = 0; i < count; i++) {\n            category_t *cat = catlist[i];\n            class_t *cls = remapClass(cat->cls);\n\n            if (!cls) {\n                // Category's target class is missing (probably weak-linked).\n                // Disavow any knowledge of this category.\n                catlist[i] = NULL;\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \"\n                                 \"missing weak-linked target class\",\n                                 cat->name, cat);\n                }\n                continue;\n            }\n\n            // Process this category. \n            // First, register the category with its target class. \n            // Then, rebuild the class's method lists (etc) if \n            // the class is realized. \n            BOOL classExists = NO;\n            if (cat->instanceMethods ||  cat->protocols \n                ||  cat->instanceProperties)\n            {\n                addUnattachedCategoryForClass(cat, cls, hi);\n                if (isRealized(cls)) {\n                    remethodizeClass(cls);\n                    classExists = YES;\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category -%s(%s) %s\",\n                                 getName(cls), cat->name,\n                                 classExists ? \"on existing class\" : \"\");\n                }\n            }\n\n            if (cat->classMethods  ||  cat->protocols \n                /* ||  cat->classProperties */)\n            {\n                addUnattachedCategoryForClass(cat, cls->isa, hi);\n                if (isRealized(cls->isa)) {\n                    remethodizeClass(cls->isa);\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category +%s(%s)\",\n                                 getName(cls), cat->name);\n                }\n            }\n        }\n    }\n```\n首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。\n略去PrintConnecting这个用于log的东西，这段代码很容易理解：\n1)、把category的实例方法、协议以及属性添加到类上\n2)、把category的类方法和协议添加到类的metaclass上\n\n值得注意的是，在代码中有一小段注释 / || cat->classProperties /，看来苹果有过给类添加属性的计划啊。\nok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：\n在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。\n\n```\nstatic void remethodizeClass(class_t *cls)\n{\n    category_list *cats;\n    BOOL isMeta;\n\n    rwlock_assert_writing(&runtimeLock);\n\n    isMeta = isMetaClass(cls);\n\n    // Re-methodizing: check for more categories\n    if ((cats = unattachedCategoriesForClass(cls))) {\n        chained_property_list *newproperties;\n        const protocol_list_t **newprotos;\n\n        if (PrintConnecting) {\n            _objc_inform(\"CLASS: attaching categories to class '%s' %s\",\n                         getName(cls), isMeta ? \"(meta)\" : \"\");\n        }\n\n        // Update methods, properties, protocols\n\n        BOOL vtableAffected = NO;\n        attachCategoryMethods(cls, cats, &vtableAffected);\n\n        newproperties = buildPropertyList(NULL, cats, isMeta);\n        if (newproperties) {\n            newproperties->next = cls->data()->properties;\n            cls->data()->properties = newproperties;\n        }\n\n        newprotos = buildProtocolList(cats, NULL, cls->data()->protocols);\n        if (cls->data()->protocols  &&  cls->data()->protocols != newprotos) {\n            _free_internal(cls->data()->protocols);\n        }\n        cls->data()->protocols = newprotos;\n\n        _free_internal(cats);\n\n        // Update method caches and vtables\n        flushCaches(cls);\n        if (vtableAffected) flushVtables(cls);\n    }\n}\n```\n而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods：\n\n```\nstatic void \nattachCategoryMethods(class_t *cls, category_list *cats,\n                      BOOL *inoutVtablesAffected)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    BOOL isMeta = isMetaClass(cls);\n    method_list_t **mlists = (method_list_t **)\n        _malloc_internal(cats->count * sizeof(*mlists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    BOOL fromBundle = NO;\n    while (i--) {\n        method_list_t *mlist = cat_method_list(cats->list[i].cat, isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= cats->list[i].fromBundle;\n        }\n    }\n\n    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);\n\n    _free_internal(mlists);\n\n}\n```\nattachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段：\n\n```\nfor (uint32_t m = 0;\n             (scanForCustomRR || scanForCustomAWZ)  &&  m < mlist->count;\n             m++)\n        {\n            SEL sel = method_list_nth(mlist, m)->name;\n            if (scanForCustomRR  &&  isRRSelector(sel)) {\n                cls->setHasCustomRR();\n                scanForCustomRR = false;\n            } else if (scanForCustomAWZ  &&  isAWZSelector(sel)) {\n                cls->setHasCustomAWZ();\n                scanForCustomAWZ = false;\n            }\n        }\n\n        // Fill method list array\n        newLists[newCount++] = mlist;\n    .\n    .\n    .\n\n    // Copy old methods to the method list array\n    for (i = 0; i < oldCount; i++) {\n        newLists[newCount++] = oldLists[i];\n    }\n```\n需要注意的有两点：\n1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA\n2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。\n### 5、旁枝末叶-category和+load方法\n我们知道，在类和category中都可以有+load方法，那么有两个问题：\n1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？\n2)、这么些个+load方法，调用顺序是咋样的呢？\n鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：\n![image](http://tech.meituan.com/img/diveintocategory/project.png)\n我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。\n在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:\n![image](http://tech.meituan.com/img/diveintocategory/environment_vars.png)\n运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：\n\nobjc[1187]: REPLACED: -[MyClass printName] by category Category1\nobjc[1187]: REPLACED: -[MyClass printName] by category Category2\n.\n.\n.\nobjc[1187]: LOAD: class 'MyClass' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category1)' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category2)' scheduled for +load\nobjc[1187]: LOAD: +[MyClass load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category1) load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category2) load]\n\n所以，对于上面两个问题，答案是很明显的：\n1)、可以调用，因为附加category到类的工作会先于+load方法的执行\n2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。\n目前的编译顺序是这样的：\n![image](http://tech.meituan.com/img/diveintocategory/compile1.png)\n我们调整一个Category1和Category2的编译顺序，run。ok，我们可以看到控制台的输出顺序变了：\n![image](http://tech.meituan.com/img/diveintocategory/compile2.png)\nobjc[1187]: REPLACED: -[MyClass printName] by category Category2\nobjc[1187]: REPLACED: -[MyClass printName] by category Category1\n.\n.\n.\nobjc[1187]: LOAD: class 'MyClass' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category2)' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category1)' scheduled for +load\nobjc[1187]: LOAD: +[MyClass load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category2) load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category1) load]\n\n虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。\n这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。\n## 6、触类旁通-category和方法覆盖\n鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:\n怎么调用到原来类中被category覆盖掉的方法？\n对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：\n\n```\nClass currentClass = [MyClass class];\nMyClass *my = [[MyClass alloc] init];\n\nif (currentClass) {\n    unsigned int methodCount;\n    Method *methodList = class_copyMethodList(currentClass, &methodCount);\n    IMP lastImp = NULL;\n    SEL lastSel = NULL;\n    for (NSInteger i = 0; i < methodCount; i++) {\n        Method method = methodList[i];\n        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) \n                                        encoding:NSUTF8StringEncoding];\n        if ([@\"printName\" isEqualToString:methodName]) {\n            lastImp = method_getImplementation(method);\n            lastSel = method_getName(method);\n        }\n    }\n    typedef void (*fn)(id,SEL);\n\n    if (lastImp != NULL) {\n        fn f = (fn)lastImp;\n        f(my,lastSel);\n    }\n    free(methodList);\n}\n```\n## 7、更上一层-category和关联对象\n如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。\n**MyClass+Category1.h:\n**\n\n```\n#import \"MyClass.h\"\n\n@interface MyClass (Category1)\n\n@property(nonatomic,copy) NSString *name;\n\n@end\n```\n**MyClass+Category1.m:\n**\n\n```\n#import \"MyClass+Category1.h\"\n#import <objc/runtime.h>\n\n@implementation MyClass (Category1)\n\n+ (void)load\n{\n    NSLog(@\"%@\",@\"load in Category1\");\n}\n\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self,\n                             \"name\",\n                             name,\n                             OBJC_ASSOCIATION_COPY);\n}\n\n- (NSString*)name\n{\n    NSString *nameObject = objc_getAssociatedObject(self, \"name\");\n    return nameObject;\n}\n\n@end\n```\n但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？\n我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：\n\n```\nvoid _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {\n    // retain the new value (if any) outside the lock.\n    ObjcAssociation old_association(0, nil);\n    id new_value = value ? acquireValue(value, policy) : nil;\n    {\n        AssociationsManager manager;\n        AssociationsHashMap &associations(manager.associations());\n        disguised_ptr_t disguised_object = DISGUISE(object);\n        if (new_value) {\n            // break any existing association.\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i != associations.end()) {\n                // secondary table exists\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    j->second = ObjcAssociation(policy, new_value);\n                } else {\n                    (*refs)[key] = ObjcAssociation(policy, new_value);\n                }\n            } else {\n                // create the new association (first time).\n                ObjectAssociationMap *refs = new ObjectAssociationMap;\n                associations[disguised_object] = refs;\n                (*refs)[key] = ObjcAssociation(policy, new_value);\n                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));\n            }\n        } else {\n            // setting the association to nil breaks the association.\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i !=  associations.end()) {\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    refs->erase(j);\n                }\n            }\n        }\n    }\n    // release the old value (outside of the lock).\n    if (old_association.hasValue()) ReleaseValue()(old_association);\n}\n```\n我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：\n\n```\nclass AssociationsManager {\n    static OSSpinLock _lock;\n    static AssociationsHashMap *_map;               // associative references:  object pointer -> PtrPtrHashMap.\npublic:\n    AssociationsManager()   { OSSpinLockLock(&_lock); }\n    ~AssociationsManager()  { OSSpinLockUnlock(&_lock); }\n\n    AssociationsHashMap &associations() {\n        if (_map == NULL)\n            _map = new AssociationsHashMap();\n        return *_map;\n    }\n};\n```\nAssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。\n而在对象的销毁逻辑里面，见objc-runtime-new.mm:\n\n```\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        Class isa_gen = _object_getClass(obj);\n        class_t *isa = newcls(isa_gen);\n\n        // Read all of the flags at once for performance.\n        bool cxx = hasCxxStructors(isa);\n        bool assoc = !UseGC && _class_instancesHaveAssociatedObjects(isa_gen);\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n\n        if (!UseGC) objc_clear_deallocating(obj);\n    }\n\n    return obj;\n}\n```\n嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。\n## 后记\n正如侯捷先生所讲-“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的(在[http://www.opensource.apple.com/tarballs/](http://www.opensource.apple.com/tarballs/)可以下载到全部的开源代码)。\n本系列runtime源码学习将会持续更新，意犹未尽的同学可以自行到上述网站下载源码学习。行笔简陋，如有错误，望指正。\n\n\n\n\n\n\n\n","slug":"深入理解Objective-C：Category","published":1,"updated":"2015-08-19T08:32:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq88000bovfyhyw35fp5"},{"title":"改变nstimer的runloopmode","date":"2015-08-21T09:41:03.000Z","_content":"```\n   NSRunLoop *rp  = [NSRunLoop currentRunLoop];\n   [rp addTimer:self.topAdView.timer forMode:NSRunLoopCommonModes];\n```\n改变nstimer的runloop模式,防止uiscrollow滚动时影响定时器的正常使用","source":"_posts/改变nstimer的runloopmode.md","raw":"title: 改变nstimer的runloopmode\ndate: 2015-08-21 17:41:03\ncategories: NSRunLoop\ntags: NSRunLoop\n\n---\n```\n   NSRunLoop *rp  = [NSRunLoop currentRunLoop];\n   [rp addTimer:self.topAdView.timer forMode:NSRunLoopCommonModes];\n```\n改变nstimer的runloop模式,防止uiscrollow滚动时影响定时器的正常使用","slug":"改变nstimer的runloopmode","published":1,"updated":"2015-08-21T09:43:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8a000eovfy7h1vif6r"},{"title":"如何建立一个简单的图片浏览器","date":"2015-08-19T03:47:44.000Z","type":"tags","_content":"##构建一个简单的photoBorwser\n","source":"_posts/如何建立一个简单的图片浏览器.md","raw":"title: 如何建立一个简单的图片浏览器\ndate: 2015-08-19 11:47:44\ntype: \"tags\"\ntags: 自定义控件\n\n---\n##构建一个简单的photoBorwser\n","slug":"如何建立一个简单的图片浏览器","published":1,"updated":"2015-08-21T01:16:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8c000jovfyxautaw3j"},{"title":"关于swift","date":"2015-08-21T02:20:27.000Z","_content":"接触IOS开始已经快三年了,oc也差不多使用两年了,从去年知道apple新推出了swift开始就在想。swift也许就像玩具一样，昙花一现，终不能取代oc20年的拼杀，然而时至今日，却突然觉得，swift已兵临城下，就待和oc一战高下，从2015wwdc大会上swift发出了最后一张战书，今年年底即将开源，2016必将是ios腥风血雨的一年。\n今天没什么事情打开github的高级搜索，蓦然发现swift已经上类似于afn的项目Alamofire已经有10000的star 最近特喜欢的reactivecocoa 在说明中明确的说出了更多新功能只会在swift中推出。唉！\n该来的总会来，来吧让这场编程争夺战来的更猛烈些吧，反正我又不乱来，接下来的一个月，要认真学习了，加油！！！","source":"_posts/关于swift.md","raw":"title: 关于swift\ndate: 2015-08-21 10:20:27\ntags: 随笔\ncategories: 随笔\n\n---\n接触IOS开始已经快三年了,oc也差不多使用两年了,从去年知道apple新推出了swift开始就在想。swift也许就像玩具一样，昙花一现，终不能取代oc20年的拼杀，然而时至今日，却突然觉得，swift已兵临城下，就待和oc一战高下，从2015wwdc大会上swift发出了最后一张战书，今年年底即将开源，2016必将是ios腥风血雨的一年。\n今天没什么事情打开github的高级搜索，蓦然发现swift已经上类似于afn的项目Alamofire已经有10000的star 最近特喜欢的reactivecocoa 在说明中明确的说出了更多新功能只会在swift中推出。唉！\n该来的总会来，来吧让这场编程争夺战来的更猛烈些吧，反正我又不乱来，接下来的一个月，要认真学习了，加油！！！","slug":"关于swift","published":1,"updated":"2015-08-21T02:34:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8e000movfygkmrtql1"},{"title":"Hello World","date":"2015-08-15T03:36:07.000Z","type":"tags","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"title: Hello World\ndate: 2015-08-15 11:36:07\ntype: \"tags\"\ntags: 随笔\n\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2015-08-18T06:18:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8g000rovfyhitq31cx"},{"title":"block写递归","date":"2015-08-20T07:34:42.000Z","type":"tags","_content":"```\nstatic int (^sumBlock)(int) = ^ (int num) {\n    if (num == 0) {\n        return num;\n    }\n    return num + sumBlock(num - 1);\n};\n```\n**注意，要做到自己调用自己，需要能够准确的在内存中找到 block 的函数入口，因此需要使用 static 修饰符号，其他就没啥了**\n\n* 每调用一次自己，系统都会开辟一个栈桢记录临时变量和参数\n* 递归次数过多，会出现栈溢出错误\n* 移动开发中不建议使用递归算法，现在主线程栈区只有 512K\n","source":"_posts/block写递归.md","raw":"title: block写递归\ndate: 2015-08-20 15:34:42\ntype: \"tags\"\ntags: Block\n\n---\n```\nstatic int (^sumBlock)(int) = ^ (int num) {\n    if (num == 0) {\n        return num;\n    }\n    return num + sumBlock(num - 1);\n};\n```\n**注意，要做到自己调用自己，需要能够准确的在内存中找到 block 的函数入口，因此需要使用 static 修饰符号，其他就没啥了**\n\n* 每调用一次自己，系统都会开辟一个栈桢记录临时变量和参数\n* 递归次数过多，会出现栈溢出错误\n* 移动开发中不建议使用递归算法，现在主线程栈区只有 512K\n","slug":"block写递归","published":1,"updated":"2015-08-20T07:37:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8h000tovfymbl6abeu"},{"title":"Objective-C消息机制的原理","date":"2015-08-17T00:55:11.000Z","type":"tags","_content":"### 在Objective-C中，message与方法的真正实现是在执行阶段绑定的，而非编译阶段。\n\n* 编译器会将消息发送转换成对objc_msgSend方法的调用。\n* objc_msgSend方法含两个必要参数：receiver、方法名（即：selector），如：\n* [receiver message]，将被转换为：objc_msgSend(receiver, selector)\n* objc_msgSend方法也能hold住message的参数，如：\n* objc_msgSend(receiver, selector, arg1, arg2, …);\n\n### objc_msgSend方法会做按照顺序进行以下操作，以完成动态绑定\t\n\n1. 查找selector所指代的程序（方法的真正实现）。因为不同类对同一方法有不同的实现，所以对方法的真正实现的查找依赖于receiver的类\n2. 调用该实现，并将一系列参数传递过去\n3. 将该实现的返回值作为自己的返回值，返回之\n\n#### 消息传递的关键是，编译器构建每个类和对象时所采用的数据结构。每个类都包含以下两个必要元素：\n\n* 一个指向父类的指针\n* 一个调度表（dispatch table）。该调度表将类的selector与方法的实际内存地址关联起来\n* 每个对象都有一个指向所属类的指针isa。通过该指针，对象可以找到它所属的类，也就找到了其全部父类，如下图所示：\n![ISA](http://dangpu-wordpress.stor.sinaapp.com/uploads/2012/07/iPhone_Message.png)\n\n当向一个对象发送消息时，objc_msgSend方法根据对象的isa指针找到对象的类，然后在类的调度表（dispatch table）中查找selector。如果无法找到selector，objc_msgSend通过指向父类的指针找到父类，并在父类的调度表（dispatch table）中查找selector，以此类推直到NSObject类。一旦查找到selector，objc_msgSend方法根据调度表的内存地址调用该实现。 通过这种方式，message与方法的真正实现在执行阶段才绑定。\n \n为了保证消息发送与执行的效率，系统会将全部selector和使用过的方法的内存地址缓存起来。每个类都有一个独立的缓存，缓存包含有当前类自己的 selector以及继承自父类的selector。查找调度表（dispatch table）前，消息发送系统首先检查receiver对象的缓存。缓存命中的情况下，消息发送（messaging）比直接调用方法（function call）只慢一点点点点。\n  \n#### 关于Selector，什么 是Selector，Selector就是一个字符串，用来表示一个方法。\n\n在Objective-C中，消息是直到运行的时候才和方法实现绑定的。编译器会把一个消息表达式，\n\n`[receiver message]`\n\n转换成一个对消息函数objc_msgSend的调用。该函数有两个主要参数：消息接收者和消息对应的方法名字——也就是方法选标：\n\n\n`objc_msgSend(receiver, selector)\n`\n\n同时接收消息中的任意数目的参数：\n\n`objc_msgSend(receiver, selector, arg1, arg2, ...)\n`\n该消息函数做了动态绑定所需要的一切：\n\n**它首先找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。**\n\n**然后将消息接收者对象（指向消息接收者对象的指针）以及方法中指定的参数传给找到的方法实现。**\n\n**最后，将方法实现的返回值作为该函数的返回值返回。**\n\n**注意：编译器将自动插入调用该消息函数的代码。您无须在代码中显示调用该消息函数。**\n\n\n\n\n\n","source":"_posts/Objective-C消息机制的原理.md","raw":"title: Objective-C消息机制的原理\ndate: 2015-08-17 08:55:11\ntype: \"tags\"\ntags: Objective-C\n## Objective-C消息机制的原理\n\n---\n### 在Objective-C中，message与方法的真正实现是在执行阶段绑定的，而非编译阶段。\n\n* 编译器会将消息发送转换成对objc_msgSend方法的调用。\n* objc_msgSend方法含两个必要参数：receiver、方法名（即：selector），如：\n* [receiver message]，将被转换为：objc_msgSend(receiver, selector)\n* objc_msgSend方法也能hold住message的参数，如：\n* objc_msgSend(receiver, selector, arg1, arg2, …);\n\n### objc_msgSend方法会做按照顺序进行以下操作，以完成动态绑定\t\n\n1. 查找selector所指代的程序（方法的真正实现）。因为不同类对同一方法有不同的实现，所以对方法的真正实现的查找依赖于receiver的类\n2. 调用该实现，并将一系列参数传递过去\n3. 将该实现的返回值作为自己的返回值，返回之\n\n#### 消息传递的关键是，编译器构建每个类和对象时所采用的数据结构。每个类都包含以下两个必要元素：\n\n* 一个指向父类的指针\n* 一个调度表（dispatch table）。该调度表将类的selector与方法的实际内存地址关联起来\n* 每个对象都有一个指向所属类的指针isa。通过该指针，对象可以找到它所属的类，也就找到了其全部父类，如下图所示：\n![ISA](http://dangpu-wordpress.stor.sinaapp.com/uploads/2012/07/iPhone_Message.png)\n\n当向一个对象发送消息时，objc_msgSend方法根据对象的isa指针找到对象的类，然后在类的调度表（dispatch table）中查找selector。如果无法找到selector，objc_msgSend通过指向父类的指针找到父类，并在父类的调度表（dispatch table）中查找selector，以此类推直到NSObject类。一旦查找到selector，objc_msgSend方法根据调度表的内存地址调用该实现。 通过这种方式，message与方法的真正实现在执行阶段才绑定。\n \n为了保证消息发送与执行的效率，系统会将全部selector和使用过的方法的内存地址缓存起来。每个类都有一个独立的缓存，缓存包含有当前类自己的 selector以及继承自父类的selector。查找调度表（dispatch table）前，消息发送系统首先检查receiver对象的缓存。缓存命中的情况下，消息发送（messaging）比直接调用方法（function call）只慢一点点点点。\n  \n#### 关于Selector，什么 是Selector，Selector就是一个字符串，用来表示一个方法。\n\n在Objective-C中，消息是直到运行的时候才和方法实现绑定的。编译器会把一个消息表达式，\n\n`[receiver message]`\n\n转换成一个对消息函数objc_msgSend的调用。该函数有两个主要参数：消息接收者和消息对应的方法名字——也就是方法选标：\n\n\n`objc_msgSend(receiver, selector)\n`\n\n同时接收消息中的任意数目的参数：\n\n`objc_msgSend(receiver, selector, arg1, arg2, ...)\n`\n该消息函数做了动态绑定所需要的一切：\n\n**它首先找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。**\n\n**然后将消息接收者对象（指向消息接收者对象的指针）以及方法中指定的参数传给找到的方法实现。**\n\n**最后，将方法实现的返回值作为该函数的返回值返回。**\n\n**注意：编译器将自动插入调用该消息函数的代码。您无须在代码中显示调用该消息函数。**\n\n\n\n\n\n","slug":"Objective-C消息机制的原理","published":1,"updated":"2015-08-17T09:12:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8j000wovfykwxio30h"},{"title":"Objective-C内存布局(转)","date":"2015-08-17T10:06:49.000Z","type":"tags","_content":"对象(object)即一块内存，本文要探讨的是一个Objective-C对象在内存的布局(layout)问题，水果的官方文档有说，一个类(class)如果不需要从NSObject继承其某些特定的行为是不用继承NSObject的，这里我将讨论限制在继承了NSObject的类的对象范围内。\n\n### 首先来看一下，NSObject的定义：\n\t@interface NSObject <NSObject> {\t\n         Class    isa;                      \n     } \n     \n(由于我们讨论的是内存布局，因此将其方法的定义撇开)\n\n在Objective-C中，@interface关键字可以看着是C语言中的struct关键字的别名，当然他还会有一些其它功能，比如说让编译器知道@interface后后面的是一个Objective-C的类的名字等。但就我们研究其内存布局来说，我们简单地将其替换为struct，并将protocal定义去掉。因此，NSObject的定义就是样：\n\n \tstruct NSObject{\n \t\tClass isa;\n \t}\n 那个这个Class又是什么呢？在objc.h中我们发现其仅仅是一个结构(struct)指针的typedef定义:\n\t\n\ttypedefstruct objc_class *Class;\n 因此，NSObject的定义就像这个样子：\n\t\n\tstruct NSObject{\n\t\tobjc_class *isa\n\t}\n\t\n\t\nisa就是“isa”，对于所有继承了NSObject的类其对象也都有一个isa指针。这个isa指针指向的东西(先这样称呼它吧)就是关于这个对象所属的类的定义。\n\n　　刨根问底是我们程序员的天性：那object_class的定义是什么呢？由于水果公司现在将这个定义隐藏起来了，不过我依然有办法，用XCode随便建一个工程，在某个变量定义处打个debug断点，然后通过XCode的GUI或者用gdb的p命令查看其结构，这里我使用gdb打印一个UINavigationController变量，我们看到只是一个指针而已：\n\t\n\t(gdb) p dialUNC\n\t$1 = (UINavigationController *) 0x8e8be80\n对指针解引用再打印，我们发现里面有很多很多东西，大致如下(由于gdb打印出来内容太多，省略号表示省略了一些内容)：\n\n```\n(gdb) p *dialUNC\n$1 = {\n  <UIViewController> = {\n    <UIResponder> = {\n      <NSObject> = {\n        isa = 0x1bebc1c\n      }, <No data fields>}, \nmembers of UIViewController: \n    _view = 0xd5dab60, \n    _tabBarItem = 0x0, \n    _navigationItem = 0x0, \n    _toolbarItems = 0x0, \n    _title = 0x0, \n    _nibName = 0x0, \n    ......(此处省略若干成员，课蜜黄蜂注)\n  }, \nmembers of UINavigationController: \n  _containerView = 0xd5dab60, \n  _navigationBar = 0xd5dad40, \n  _navigationBarClass = 0x1beb4d8, \n  _toolbar = 0x0, \n  _navigationTransitionView = 0xd5d2f10, \n  _currentScrollContentInsetDelta = {\n    top = 0, \n    left = 0, \n    bottom = 0, \n    right = 0\n  }, \n  _previousScrollContentInsetDelta = {\n    top = 0, \n    left = 0, \n    bottom = 0, \n    right = 0\n  }, \n  ......（此处省略若干成员，课蜜黄蜂注） \n  }\n}\n```\n注意gdb打印结果中的黑体字，从中我们可以看到，UINavigationController内存中先是存放了父类的实例变量再存放子类的实例变量。最前面的那个isa指针就是在NSObject中所定义的。由于Objective-C中没有多继承，因此其内存布局还是很简单的，就是：最前面有个isa指针，然后父类的实例变量存放在子类的成员变量之前，so easy!!!但还有一个问题，我们很好奇，这个isa是什么呢？对它解引用再打印内容大致如下：\n\n```\n(gdb) p *dialUNC->isa\n$2 = {\n    isa = 0x1bebc30, \n    super_class = 0x1bebba4, \n    name = 0xd5dd8d0 \"?\", \n    version = 45024840, \n    info = 223886032, \n    instance_size = 43102048, \n    ivars = 0x1bebb7c, \n    methodLists = 0xd5dab10, \n    cache = 0x2af0648, \n    protocols = 0xd584050\n}\n```\n这就是一个Class或者说objc_class结构在内存中的样子。其实在Objective-C2.0之前这个结构的定义是暴露给用户的，但在Objective-C2.0中，水果公司将它隐藏起来了。经过在网上的查找，发现在Objective-C2.0之前其定义大致如下：\n\n```\nstruct objc_class {\n    Class isa;\n    \n    Class super_class;\n    \n    const char *name;\n    \n    long version;\n    long info;\n    \n    long instance_size;\n    struct objc_ivar_list *ivars;\n    struct objc_method_list **methodLists; \n    \n    struct objc_cache *cache;\n    struct objc_protocol_list *protocols;   \n}\n```\n因此简单地说，一个objc_class对象包括一个类的：父类定义(super_class), 变量列表，方法列表，还有实现了哪些协议(Protocal)等等。\n\n　　\"等一下\"，有人要喊了，\"我们刚才在说一个对象里面有一个isa指针，这个指针的定义是objc_class,肿么这个objc-class中还有一个isa？\"\n\n　　在这里有必要跟大家啰嗦一大段文字了：在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是水果公司说的类对象(class object),他是一个单例(singleton), 而我们在C++等语言中所谓的对象，叫做实例对象(instance object)。对于实例对象我们不难理解，但类对象(class object)是干什么吃的呢？我们知道Objective-C是门很动态的语言，因此程序里的所有实例对象(instace objec)都是在运行时由Objective-C的运行时库生成的，而这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。\n\n　　让我们来理一下，到目前为止，我们知道了：任何直接或间接继承了NSObject的类，它的实例对象(instacne objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等。\n\n　　再回到之前的问题，肿么这个实例对象(instance object)的isa指针指向的类对象(class object)里面还有一个isa呢？\n\n　　这个类对象(class objec)的isa指向的依然是一个objc-class，它就是“元类对象”(metaclass object)，它和类对象(class object)的关系是这样的:  类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。类对象和元类对象中水果公司当然还会包含一些其它的东西，以后也可能添加其它的内容，但对于我们了解其内存布局来说，只需要记住：类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。要注意的是，类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)。关于元类对象水果官方文档\" The Objective-‐C Programming Language \"P29页顶部描述如下：\n\n　　Note: The compiler also builds a metaclass object for each class. It describes the class object just as the class object describes instances of the class. But while you can send messages to instances and to the class object, the metaclass object is used only internally by the runtime system. \n\n　　这一大段文字好像有点绕，那我们来看一个例子。下面我以一个有4层继承关系的类的实例变量的内存布局为例。　继承关系如下：\n　　\n\t![id](https://app.yinxiang.com/shard/s39/res/c2c0004f-7702-4978-b2d2-c41482f75344.jpg?resizeSmall&width=846)\n　　\n　　通过打印D3类的一个实例变量并将那些isa,super_class的地地址记录下来整理得到的关系如下图:\n\n![id](https://app.yinxiang.com/shard/s39/res/2eaaccde-e5d6-4635-a3c5-982bfaaa0892.png?resizeSmall&width=846)\n\n在这里对上图进行一下解释： 矩形表示对象(object),即一块内存;箭头表示指针，isa即isa指针，super表示super_class指针，这些指针是箭头尾部对象(object)的成员变量，除了“D3实例对象”(最左边的对象)，其它对象都是在程序一启动就创建在在内存中的了而且都是单例(singleton)，类对象(class object)和元类对象(metaclass object)只是用途不一样，其定义都为objc_class结构\n\n\n　　D3对象的内存布局为:从前往后为isa,D1的实例变量,D2的实例变量,D3的实例变量。而isa指针指向的内容就是上图中的“D3类对象”。对于上图，任何类C如果直接或间接继承NSObject 或者其就是NSObject,则有如下结论：\n\n　　**1. 类C的类对象(class object)的super_class都指向了类C父类的类对象(class object), NSObject的类对像的super_class指向0x0**\n\n**　　2. 类C的类对象(class object)的isa指针都指向他的元类对象(metaclass object)\n**\n\n**　　3. 类C的元类对象(metaclass object)的super_class指针指向父类的元类对象(metaclass object), 例外：NSObject的元类对象(metaclass object)的super_class指向NSObject的类对象(class object).\n**\n\n**　　4. 类C的元类对象(metaclass object)的isa指针指都指向NSObject的元类对象(metaclass object)\n**\n　　NSObject的实例对象(虽然它没有实例变量和实例方法但这个对象仍然存在)其super_class指向地址0x0，因为NSObject没有父类, 这满足上面的结论1。　\n　　NSObject的实例对象的isa指向了NSObject的元类对象(metaclass object)，这满足上面结论2。　　\n　　NSObject的元类对象(metaclass object)指向了自己，这也满足上面结论4。　　\n　　但NSObject的元类对象(metaclass object)的super_class指向了NSObject的类对象(class object)，我没有看出什么规律可言或者苹果为什么要这样做，我只能说“Apple just do this, I don't know why”（如果有人知道，麻烦告诉我一下，多谢）。我认为水果的工程师们只是简单地又将它指向NSObject的类对象(class object)，其实我认为这个super_class指针赋0x0也未尝不可(这样就满足上面的结论3， 因为NSObject没有父类，所以它的metaclass object的super_class指向0x0，我觉得这样更统一。当然只是我的yy罢了)。 \n\n`原文地址:http://www.cnblogs.com/csutanyu/archive/2011/12/12/Objective-C_memor_layout.html　`\n\n　　","source":"_posts/Objective-C内存布局.md","raw":"title: Objective-C内存布局(转)\ndate: 2015-08-17 18:06:49\ntype: \"tags\"\ntags: Objective-C\n## Objective-C内存布局\n\n---\n对象(object)即一块内存，本文要探讨的是一个Objective-C对象在内存的布局(layout)问题，水果的官方文档有说，一个类(class)如果不需要从NSObject继承其某些特定的行为是不用继承NSObject的，这里我将讨论限制在继承了NSObject的类的对象范围内。\n\n### 首先来看一下，NSObject的定义：\n\t@interface NSObject <NSObject> {\t\n         Class    isa;                      \n     } \n     \n(由于我们讨论的是内存布局，因此将其方法的定义撇开)\n\n在Objective-C中，@interface关键字可以看着是C语言中的struct关键字的别名，当然他还会有一些其它功能，比如说让编译器知道@interface后后面的是一个Objective-C的类的名字等。但就我们研究其内存布局来说，我们简单地将其替换为struct，并将protocal定义去掉。因此，NSObject的定义就是样：\n\n \tstruct NSObject{\n \t\tClass isa;\n \t}\n 那个这个Class又是什么呢？在objc.h中我们发现其仅仅是一个结构(struct)指针的typedef定义:\n\t\n\ttypedefstruct objc_class *Class;\n 因此，NSObject的定义就像这个样子：\n\t\n\tstruct NSObject{\n\t\tobjc_class *isa\n\t}\n\t\n\t\nisa就是“isa”，对于所有继承了NSObject的类其对象也都有一个isa指针。这个isa指针指向的东西(先这样称呼它吧)就是关于这个对象所属的类的定义。\n\n　　刨根问底是我们程序员的天性：那object_class的定义是什么呢？由于水果公司现在将这个定义隐藏起来了，不过我依然有办法，用XCode随便建一个工程，在某个变量定义处打个debug断点，然后通过XCode的GUI或者用gdb的p命令查看其结构，这里我使用gdb打印一个UINavigationController变量，我们看到只是一个指针而已：\n\t\n\t(gdb) p dialUNC\n\t$1 = (UINavigationController *) 0x8e8be80\n对指针解引用再打印，我们发现里面有很多很多东西，大致如下(由于gdb打印出来内容太多，省略号表示省略了一些内容)：\n\n```\n(gdb) p *dialUNC\n$1 = {\n  <UIViewController> = {\n    <UIResponder> = {\n      <NSObject> = {\n        isa = 0x1bebc1c\n      }, <No data fields>}, \nmembers of UIViewController: \n    _view = 0xd5dab60, \n    _tabBarItem = 0x0, \n    _navigationItem = 0x0, \n    _toolbarItems = 0x0, \n    _title = 0x0, \n    _nibName = 0x0, \n    ......(此处省略若干成员，课蜜黄蜂注)\n  }, \nmembers of UINavigationController: \n  _containerView = 0xd5dab60, \n  _navigationBar = 0xd5dad40, \n  _navigationBarClass = 0x1beb4d8, \n  _toolbar = 0x0, \n  _navigationTransitionView = 0xd5d2f10, \n  _currentScrollContentInsetDelta = {\n    top = 0, \n    left = 0, \n    bottom = 0, \n    right = 0\n  }, \n  _previousScrollContentInsetDelta = {\n    top = 0, \n    left = 0, \n    bottom = 0, \n    right = 0\n  }, \n  ......（此处省略若干成员，课蜜黄蜂注） \n  }\n}\n```\n注意gdb打印结果中的黑体字，从中我们可以看到，UINavigationController内存中先是存放了父类的实例变量再存放子类的实例变量。最前面的那个isa指针就是在NSObject中所定义的。由于Objective-C中没有多继承，因此其内存布局还是很简单的，就是：最前面有个isa指针，然后父类的实例变量存放在子类的成员变量之前，so easy!!!但还有一个问题，我们很好奇，这个isa是什么呢？对它解引用再打印内容大致如下：\n\n```\n(gdb) p *dialUNC->isa\n$2 = {\n    isa = 0x1bebc30, \n    super_class = 0x1bebba4, \n    name = 0xd5dd8d0 \"?\", \n    version = 45024840, \n    info = 223886032, \n    instance_size = 43102048, \n    ivars = 0x1bebb7c, \n    methodLists = 0xd5dab10, \n    cache = 0x2af0648, \n    protocols = 0xd584050\n}\n```\n这就是一个Class或者说objc_class结构在内存中的样子。其实在Objective-C2.0之前这个结构的定义是暴露给用户的，但在Objective-C2.0中，水果公司将它隐藏起来了。经过在网上的查找，发现在Objective-C2.0之前其定义大致如下：\n\n```\nstruct objc_class {\n    Class isa;\n    \n    Class super_class;\n    \n    const char *name;\n    \n    long version;\n    long info;\n    \n    long instance_size;\n    struct objc_ivar_list *ivars;\n    struct objc_method_list **methodLists; \n    \n    struct objc_cache *cache;\n    struct objc_protocol_list *protocols;   \n}\n```\n因此简单地说，一个objc_class对象包括一个类的：父类定义(super_class), 变量列表，方法列表，还有实现了哪些协议(Protocal)等等。\n\n　　\"等一下\"，有人要喊了，\"我们刚才在说一个对象里面有一个isa指针，这个指针的定义是objc_class,肿么这个objc-class中还有一个isa？\"\n\n　　在这里有必要跟大家啰嗦一大段文字了：在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是水果公司说的类对象(class object),他是一个单例(singleton), 而我们在C++等语言中所谓的对象，叫做实例对象(instance object)。对于实例对象我们不难理解，但类对象(class object)是干什么吃的呢？我们知道Objective-C是门很动态的语言，因此程序里的所有实例对象(instace objec)都是在运行时由Objective-C的运行时库生成的，而这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。\n\n　　让我们来理一下，到目前为止，我们知道了：任何直接或间接继承了NSObject的类，它的实例对象(instacne objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等。\n\n　　再回到之前的问题，肿么这个实例对象(instance object)的isa指针指向的类对象(class object)里面还有一个isa呢？\n\n　　这个类对象(class objec)的isa指向的依然是一个objc-class，它就是“元类对象”(metaclass object)，它和类对象(class object)的关系是这样的:  类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。类对象和元类对象中水果公司当然还会包含一些其它的东西，以后也可能添加其它的内容，但对于我们了解其内存布局来说，只需要记住：类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。要注意的是，类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)。关于元类对象水果官方文档\" The Objective-‐C Programming Language \"P29页顶部描述如下：\n\n　　Note: The compiler also builds a metaclass object for each class. It describes the class object just as the class object describes instances of the class. But while you can send messages to instances and to the class object, the metaclass object is used only internally by the runtime system. \n\n　　这一大段文字好像有点绕，那我们来看一个例子。下面我以一个有4层继承关系的类的实例变量的内存布局为例。　继承关系如下：\n　　\n\t![id](https://app.yinxiang.com/shard/s39/res/c2c0004f-7702-4978-b2d2-c41482f75344.jpg?resizeSmall&width=846)\n　　\n　　通过打印D3类的一个实例变量并将那些isa,super_class的地地址记录下来整理得到的关系如下图:\n\n![id](https://app.yinxiang.com/shard/s39/res/2eaaccde-e5d6-4635-a3c5-982bfaaa0892.png?resizeSmall&width=846)\n\n在这里对上图进行一下解释： 矩形表示对象(object),即一块内存;箭头表示指针，isa即isa指针，super表示super_class指针，这些指针是箭头尾部对象(object)的成员变量，除了“D3实例对象”(最左边的对象)，其它对象都是在程序一启动就创建在在内存中的了而且都是单例(singleton)，类对象(class object)和元类对象(metaclass object)只是用途不一样，其定义都为objc_class结构\n\n\n　　D3对象的内存布局为:从前往后为isa,D1的实例变量,D2的实例变量,D3的实例变量。而isa指针指向的内容就是上图中的“D3类对象”。对于上图，任何类C如果直接或间接继承NSObject 或者其就是NSObject,则有如下结论：\n\n　　**1. 类C的类对象(class object)的super_class都指向了类C父类的类对象(class object), NSObject的类对像的super_class指向0x0**\n\n**　　2. 类C的类对象(class object)的isa指针都指向他的元类对象(metaclass object)\n**\n\n**　　3. 类C的元类对象(metaclass object)的super_class指针指向父类的元类对象(metaclass object), 例外：NSObject的元类对象(metaclass object)的super_class指向NSObject的类对象(class object).\n**\n\n**　　4. 类C的元类对象(metaclass object)的isa指针指都指向NSObject的元类对象(metaclass object)\n**\n　　NSObject的实例对象(虽然它没有实例变量和实例方法但这个对象仍然存在)其super_class指向地址0x0，因为NSObject没有父类, 这满足上面的结论1。　\n　　NSObject的实例对象的isa指向了NSObject的元类对象(metaclass object)，这满足上面结论2。　　\n　　NSObject的元类对象(metaclass object)指向了自己，这也满足上面结论4。　　\n　　但NSObject的元类对象(metaclass object)的super_class指向了NSObject的类对象(class object)，我没有看出什么规律可言或者苹果为什么要这样做，我只能说“Apple just do this, I don't know why”（如果有人知道，麻烦告诉我一下，多谢）。我认为水果的工程师们只是简单地又将它指向NSObject的类对象(class object)，其实我认为这个super_class指针赋0x0也未尝不可(这样就满足上面的结论3， 因为NSObject没有父类，所以它的metaclass object的super_class指向0x0，我觉得这样更统一。当然只是我的yy罢了)。 \n\n`原文地址:http://www.cnblogs.com/csutanyu/archive/2011/12/12/Objective-C_memor_layout.html　`\n\n　　","slug":"Objective-C内存布局","published":1,"updated":"2015-08-18T08:31:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8k000yovfyw2i1e4dz"},{"title":"ImageWithColor","date":"2015-08-19T08:23:27.000Z","type":"tags","_content":"```\n@interface UIImage (Color)  \n  \n+ (UIImage *)imageWithColor:(UIColor *)color size:(CGSize)size;  \n  \n@end  \n  \n@implementation UIImage (Color)  \n  \n+ (UIImage *)imageWithColor:(UIColor *)color size:(CGSize)size  \n{  \n    CGRect rect = CGRectMake(0, 0, size.width, size.height);  \n    UIGraphicsBeginImageContext(rect.size);  \n    CGContextRef context = UIGraphicsGetCurrentContext();  \n    CGContextSetFillColorWithColor(context,color.CGColor);  \n    CGContextFillRect(context, rect);  \n    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();  \n    UIGraphicsEndImageContext();  \n      \n    return img;  \n}  \n@end \n```\n","source":"_posts/ImageWithColor.md","raw":"title: ImageWithColor\ndate: 2015-08-19 16:23:27\ntype: \"tags\"\ntags: 实用小工具\n\n---\n```\n@interface UIImage (Color)  \n  \n+ (UIImage *)imageWithColor:(UIColor *)color size:(CGSize)size;  \n  \n@end  \n  \n@implementation UIImage (Color)  \n  \n+ (UIImage *)imageWithColor:(UIColor *)color size:(CGSize)size  \n{  \n    CGRect rect = CGRectMake(0, 0, size.width, size.height);  \n    UIGraphicsBeginImageContext(rect.size);  \n    CGContextRef context = UIGraphicsGetCurrentContext();  \n    CGContextSetFillColorWithColor(context,color.CGColor);  \n    CGContextFillRect(context, rect);  \n    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();  \n    UIGraphicsEndImageContext();  \n      \n    return img;  \n}  \n@end \n```\n","slug":"ImageWithColor","published":1,"updated":"2015-08-19T08:29:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8m0010ovfy19ny9lx0"},{"title":"IOS距离传感器","date":"2015-08-24T00:59:42.000Z","_content":"```\n\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    // 1.开启距离传感器(注意: 默认情况距离传感器是关闭的)\n//    [UIApplication sharedApplication].proximitySensingEnabled = YES;\n    // 只要开启之后, 就开始实时监听\n    [UIDevice currentDevice].proximityMonitoringEnabled = YES;\n    \n    // 2.当监听到有物体靠近设备时系统会发出通知\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(proximityStateDidChange:) name:UIDeviceProximityStateDidChangeNotification object:nil];\n    \n}\n- (void)dealloc\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n\n// 当监听到有物体靠近设备时调用\n- (void)proximityStateDidChange:(NSNotification *)note\n{\n//    NSLog(@\"%@\", note);\n   if( [UIDevice currentDevice].proximityState)\n   {\n       NSLog(@\"有物体靠近\");\n   }else\n   {\n       NSLog(@\"物体离开\");\n   }\n}\n\n\n\n\n@end\n```\n","source":"_posts/IOS距离传感器.md","raw":"title: IOS距离传感器\ndate: 2015-08-24 08:59:42\ntags: IOS\n\n---\n```\n\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    // 1.开启距离传感器(注意: 默认情况距离传感器是关闭的)\n//    [UIApplication sharedApplication].proximitySensingEnabled = YES;\n    // 只要开启之后, 就开始实时监听\n    [UIDevice currentDevice].proximityMonitoringEnabled = YES;\n    \n    // 2.当监听到有物体靠近设备时系统会发出通知\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(proximityStateDidChange:) name:UIDeviceProximityStateDidChangeNotification object:nil];\n    \n}\n- (void)dealloc\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n\n// 当监听到有物体靠近设备时调用\n- (void)proximityStateDidChange:(NSNotification *)note\n{\n//    NSLog(@\"%@\", note);\n   if( [UIDevice currentDevice].proximityState)\n   {\n       NSLog(@\"有物体靠近\");\n   }else\n   {\n       NSLog(@\"物体离开\");\n   }\n}\n\n\n\n\n@end\n```\n","slug":"IOS距离传感器","published":1,"updated":"2015-08-24T01:00:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8n0012ovfyneuxcviu"},{"title":"IOS-播放在线视频","date":"2015-08-24T01:13:41.000Z","_content":"### 第一种：\n//UIWebView 加在网络视频 在线播放  有声音\n\nUIWebView *myWeb = [[UIWebView alloc] initWithFrame:self.view.bounds];\n\nNSURL *url = [NSURLURLWithString:@\"\nhttp://devimages.apple.com/iphone/samples/bipbop/gear1/prog_index.m3u8\"];\nhttp://devimages.apple.com/iphone/samples/bipbop/gear1/prog_index.m3u8//这里也可以是 mp4\n\nNSURLRequest *request = [NSURLRequest requestWithURL:url];\n\n[myWeb setDelegate:self];\n\n[myWeb loadRequest:request];\n\n[self.view addSubview:myWeb];\n### 第二种：\n\n//AVPlayerLayer 播放在线视频  无声音\n\nNSURL *sourceMovieURL = [NSURL URLWithString:@\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\"];\n\nAVAsset *movieAsset    = [AVURLAsset URLAssetWithURL:sourceMovieURLoptions:nil];\n\nAVPlayerItem *playerItem = [AVPlayerItem playerItemWithAsset:movieAsset];\n\nAVPlayer *player = [AVPlayer playerWithPlayerItem:playerItem];\n\nAVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];\n\nplayerLayer.frame = self.view.layer.bounds;\n\nplayerLayer.videoGravity = AVLayerVideoGravityResizeAspect;\n\n[self.view.layer addSublayer:playerLayer];\n\n转载请标明出处，黄志勇的个人博客！\n\n[player play];\n### 第三种：\n\n//MPMoviePlayerController 播放在线视频  无声音\n\nNSURL *videoURL = [NSURLURLWithString:@\"https://s3.amazonaws.com/adplayer/colgate.mp4\"];\n\nMPMoviePlayerViewcontroller *moviePlayerController = [[MPMoviePlayerViewcontroller alloc] initWithContentURL:videoURL];\n\nmoviePlayerController.moviePlayer.movieSourceType = MPMovieSourceTypeFile;\n\nmoviePlayerController.moviePlayer.shouldAutoplay = YES;\n\n//moviePlayerController.moviePlayer.controlStyle = MPMovieControlStyleNone;\n\n[moviePlayerController.moviePlayer prepareToPlay];\n\n[moviePlayerController.moviePlayer play];\n\n[[NSnotificationCenter defaultCenter]\n\naddObserver: self\n\nselector: @selector(myMovieFinishedCallback:)\n\nname: MPMoviePlayerPlaybackDidFinishnotification\n\nobject: moviePlayerController];\n\n[self presentMoviePlayerViewcontrollerAnimated:moviePlayerController];\n### 题记\n简单的视频在线播放,可以使用第三方框架MWphotoborwser","source":"_posts/IOS-播放在线视频.md","raw":"title: IOS-播放在线视频\ndate: 2015-08-24 09:13:41\ntags: IOS\n\n---\n### 第一种：\n//UIWebView 加在网络视频 在线播放  有声音\n\nUIWebView *myWeb = [[UIWebView alloc] initWithFrame:self.view.bounds];\n\nNSURL *url = [NSURLURLWithString:@\"\nhttp://devimages.apple.com/iphone/samples/bipbop/gear1/prog_index.m3u8\"];\nhttp://devimages.apple.com/iphone/samples/bipbop/gear1/prog_index.m3u8//这里也可以是 mp4\n\nNSURLRequest *request = [NSURLRequest requestWithURL:url];\n\n[myWeb setDelegate:self];\n\n[myWeb loadRequest:request];\n\n[self.view addSubview:myWeb];\n### 第二种：\n\n//AVPlayerLayer 播放在线视频  无声音\n\nNSURL *sourceMovieURL = [NSURL URLWithString:@\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\"];\n\nAVAsset *movieAsset    = [AVURLAsset URLAssetWithURL:sourceMovieURLoptions:nil];\n\nAVPlayerItem *playerItem = [AVPlayerItem playerItemWithAsset:movieAsset];\n\nAVPlayer *player = [AVPlayer playerWithPlayerItem:playerItem];\n\nAVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];\n\nplayerLayer.frame = self.view.layer.bounds;\n\nplayerLayer.videoGravity = AVLayerVideoGravityResizeAspect;\n\n[self.view.layer addSublayer:playerLayer];\n\n转载请标明出处，黄志勇的个人博客！\n\n[player play];\n### 第三种：\n\n//MPMoviePlayerController 播放在线视频  无声音\n\nNSURL *videoURL = [NSURLURLWithString:@\"https://s3.amazonaws.com/adplayer/colgate.mp4\"];\n\nMPMoviePlayerViewcontroller *moviePlayerController = [[MPMoviePlayerViewcontroller alloc] initWithContentURL:videoURL];\n\nmoviePlayerController.moviePlayer.movieSourceType = MPMovieSourceTypeFile;\n\nmoviePlayerController.moviePlayer.shouldAutoplay = YES;\n\n//moviePlayerController.moviePlayer.controlStyle = MPMovieControlStyleNone;\n\n[moviePlayerController.moviePlayer prepareToPlay];\n\n[moviePlayerController.moviePlayer play];\n\n[[NSnotificationCenter defaultCenter]\n\naddObserver: self\n\nselector: @selector(myMovieFinishedCallback:)\n\nname: MPMoviePlayerPlaybackDidFinishnotification\n\nobject: moviePlayerController];\n\n[self presentMoviePlayerViewcontrollerAnimated:moviePlayerController];\n### 题记\n简单的视频在线播放,可以使用第三方框架MWphotoborwser","slug":"IOS-播放在线视频","published":1,"updated":"2015-08-24T01:27:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8p0014ovfyfrqcrk4p"},{"title":"IOS-摇一摇","date":"2015-08-24T01:06:08.000Z","_content":"```\n\n#import \"AppDelegate.h\"\n\n@interface AppDelegate ()\n\n@end\n\n@implementation AppDelegate\n\n/**\n *  开始摇晃就会调用\n */\n- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event\n{\n    NSLog(@\"%s\", __func__);\n}\n/**\n *  摇晃结束就会调用\n */\n- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event\n{\n     NSLog(@\"%s\", __func__);\n}\n/**\n *  摇晃被打断就会调用\n */\n- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event\n{\n     NSLog(@\"%s\", __func__);\n}\n\n@end\n\n```\n","source":"_posts/IOS-摇一摇.md","raw":"title: IOS-摇一摇\ndate: 2015-08-24 09:06:08\ntags: IOS\n\n---\n```\n\n#import \"AppDelegate.h\"\n\n@interface AppDelegate ()\n\n@end\n\n@implementation AppDelegate\n\n/**\n *  开始摇晃就会调用\n */\n- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event\n{\n    NSLog(@\"%s\", __func__);\n}\n/**\n *  摇晃结束就会调用\n */\n- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event\n{\n     NSLog(@\"%s\", __func__);\n}\n/**\n *  摇晃被打断就会调用\n */\n- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event\n{\n     NSLog(@\"%s\", __func__);\n}\n\n@end\n\n```\n","slug":"IOS-摇一摇","published":1,"updated":"2015-08-24T01:06:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8q0016ovfyjz9a2d7k"},{"title":"IOS-UIAccelerometer","date":"2015-08-24T01:01:57.000Z","_content":"```\n#import \"ViewController.h\"\n#import \"UIView+Extension.h\"\n\n@interface ViewController ()<UIAccelerometerDelegate>\n/**\n *  小球\n */\n@property (weak, nonatomic) IBOutlet UIImageView *imageBall;\n/**\n *  保存速度\n */\n@property (nonatomic, assign) CGPoint  velocity;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    // 1.利用单利获取采集对象\n    UIAccelerometer *acc = [UIAccelerometer sharedAccelerometer];\n    // 2.设置代理\n    acc.delegate = self;\n    // 3.设置采样时间\n    acc.updateInterval = 1 / 30;\n\n}\n#pragma mark -UIAccelerometerDelegate\n// 4.实现代理方法\n/**\n *  只要采集到数据就会调用(调用频率非常高)\n *\n *  @param accelerometer 触发事件的对象\n *  @param acceleration  获取到得数据\n */\n- (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration\n{\n    NSLog(@\"x = %f / y = %f / z = %f\", acceleration.x, acceleration.y, acceleration.z);\n    \n    /*\n     速度 = 加速度 * 时间\n     V = at;  ==  a * t1 + a * t2 + a * t3 ....;\n     */\n    // 不能直接修改对象的结构体属性的成员\n//    self.velocity.x += acceleration.x;\n    _velocity.x += acceleration.x;\n    // -=的原因是因为获取到得Y轴的加速度和UIKit的坐标系的Y的值是相反的, 而我们将来想让小球往加速度的反方向运动, 所以 -=;\n    _velocity.y -= acceleration.y;\n    \n    /*\n     \n    移动的距离 = 速度 * 时间\n    S = vt; == v * t1 + v * t2 + v * t3 ....;\n     */\n    self.imageBall.x += _velocity.x;\n    self.imageBall.y += _velocity.y;\n    \n    // 边界检测\n    if (self.imageBall.x <= 0) {\n        // 矫正小球当前的位置\n        self.imageBall.x = 0;\n        // 超出了屏幕的左边\n        _velocity.x *= -0.5;\n    }\n    if (self.imageBall.y <= 0) {\n        // 矫正小球当前的位置\n        self.imageBall.y = 0;\n        // 超出屏幕的顶部\n        _velocity.y *= -0.5;\n    }\n    \n    if (CGRectGetMaxY(self.imageBall.frame) >= self.view.height) {\n        // 矫正小球当前的位置\n        self.imageBall.y = self.view.height - self.imageBall.height;\n        // 查出屏幕的底部\n        _velocity.y *= -0.5;\n    }\n    \n    if (CGRectGetMaxX(self.imageBall.frame) >= self.view.width) {\n        // 矫正小球当前的位置\n        self.imageBall.x = self.view.width - self.imageBall.width;\n        // 查出屏幕的右边\n        _velocity.x *= -0.5;\n    }\n    \n}\n@end\n\n```\n","source":"_posts/IOS-UIAccelerometer.md","raw":"title: IOS-UIAccelerometer\ndate: 2015-08-24 09:01:57\ntags: IOS\n\n---\n```\n#import \"ViewController.h\"\n#import \"UIView+Extension.h\"\n\n@interface ViewController ()<UIAccelerometerDelegate>\n/**\n *  小球\n */\n@property (weak, nonatomic) IBOutlet UIImageView *imageBall;\n/**\n *  保存速度\n */\n@property (nonatomic, assign) CGPoint  velocity;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    // 1.利用单利获取采集对象\n    UIAccelerometer *acc = [UIAccelerometer sharedAccelerometer];\n    // 2.设置代理\n    acc.delegate = self;\n    // 3.设置采样时间\n    acc.updateInterval = 1 / 30;\n\n}\n#pragma mark -UIAccelerometerDelegate\n// 4.实现代理方法\n/**\n *  只要采集到数据就会调用(调用频率非常高)\n *\n *  @param accelerometer 触发事件的对象\n *  @param acceleration  获取到得数据\n */\n- (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration\n{\n    NSLog(@\"x = %f / y = %f / z = %f\", acceleration.x, acceleration.y, acceleration.z);\n    \n    /*\n     速度 = 加速度 * 时间\n     V = at;  ==  a * t1 + a * t2 + a * t3 ....;\n     */\n    // 不能直接修改对象的结构体属性的成员\n//    self.velocity.x += acceleration.x;\n    _velocity.x += acceleration.x;\n    // -=的原因是因为获取到得Y轴的加速度和UIKit的坐标系的Y的值是相反的, 而我们将来想让小球往加速度的反方向运动, 所以 -=;\n    _velocity.y -= acceleration.y;\n    \n    /*\n     \n    移动的距离 = 速度 * 时间\n    S = vt; == v * t1 + v * t2 + v * t3 ....;\n     */\n    self.imageBall.x += _velocity.x;\n    self.imageBall.y += _velocity.y;\n    \n    // 边界检测\n    if (self.imageBall.x <= 0) {\n        // 矫正小球当前的位置\n        self.imageBall.x = 0;\n        // 超出了屏幕的左边\n        _velocity.x *= -0.5;\n    }\n    if (self.imageBall.y <= 0) {\n        // 矫正小球当前的位置\n        self.imageBall.y = 0;\n        // 超出屏幕的顶部\n        _velocity.y *= -0.5;\n    }\n    \n    if (CGRectGetMaxY(self.imageBall.frame) >= self.view.height) {\n        // 矫正小球当前的位置\n        self.imageBall.y = self.view.height - self.imageBall.height;\n        // 查出屏幕的底部\n        _velocity.y *= -0.5;\n    }\n    \n    if (CGRectGetMaxX(self.imageBall.frame) >= self.view.width) {\n        // 矫正小球当前的位置\n        self.imageBall.x = self.view.width - self.imageBall.width;\n        // 查出屏幕的右边\n        _velocity.x *= -0.5;\n    }\n    \n}\n@end\n\n```\n","slug":"IOS-UIAccelerometer","published":1,"updated":"2015-08-24T01:03:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8t0018ovfybws4za80"},{"title":"IOS-UI-Tips(-)之UITabelviewCell-Height","date":"2015-08-18T03:36:07.000Z","type":"tags","_content":"## UITableView中cell高度计算问题之\n如何解决类似于微博cell高度问题\n\n### 首先我们先确定一下两个函数问题\n\n\t- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n\n\t- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n\n根据我们一开始学习IOS时候的经验，height肯定是在UITableViewCell前面运行的。\n实际上height虽说是在cell前面运行的，但是，cell运行完了以后，会再一次调用height,这个height才是cell的最终高度。这也就是说在整个tableview的刷新过程中每一个cell对应的height函数会调用2次,一前一后,这也是今天如何解决不规则cell高度的关键。\n\n### 我们拿到数据源 DataArray 执行 [self.tableView reloadData]会执行\n\n\t- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n\n这个会遍历数组中的所有object 这个时候我们就可以在这里计算高度了(label、button、imageview)等,然后保存在mode中\n等循环结束以后会执行\n\n\t- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n\n最后再调用\n\n\t- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n\n现实在UITableView上。有些同学会觉得，运行了2次是不是很麻烦,首先呢 ，我想说的是，你知道这个调用顺序以后 可以优化时间 比如第一次计算高度的时候 就可以保存在模型中。后面2次都可以直接拿过来用。\n其次,对于文字高度比较好计算，但是对于单张图片的高度 ，这个就有点头疼了。曾经我问过一个朋友，他说服务器会直接反悔image的size 好吧 ，这个有这些数据的朋友们，当我没说。\n其次呢，没有怎么办呢，这个就是2次运行height函数的好处了。\n\n### 对于第一次函数 我们可以下载图片的缩略图以便在后面的计算高度中可以直接使用","source":"_posts/IOS-UI-Tips-之UITabelviewCell-Height.md","raw":"title: IOS-UI-Tips(-)之UITabelviewCell-Height\ndate: 2015-08-18 11:36:07\ntype: \"tags\"\ntags: UI\n\n---\n## UITableView中cell高度计算问题之\n如何解决类似于微博cell高度问题\n\n### 首先我们先确定一下两个函数问题\n\n\t- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n\n\t- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n\n根据我们一开始学习IOS时候的经验，height肯定是在UITableViewCell前面运行的。\n实际上height虽说是在cell前面运行的，但是，cell运行完了以后，会再一次调用height,这个height才是cell的最终高度。这也就是说在整个tableview的刷新过程中每一个cell对应的height函数会调用2次,一前一后,这也是今天如何解决不规则cell高度的关键。\n\n### 我们拿到数据源 DataArray 执行 [self.tableView reloadData]会执行\n\n\t- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n\n这个会遍历数组中的所有object 这个时候我们就可以在这里计算高度了(label、button、imageview)等,然后保存在mode中\n等循环结束以后会执行\n\n\t- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n\n最后再调用\n\n\t- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n\n现实在UITableView上。有些同学会觉得，运行了2次是不是很麻烦,首先呢 ，我想说的是，你知道这个调用顺序以后 可以优化时间 比如第一次计算高度的时候 就可以保存在模型中。后面2次都可以直接拿过来用。\n其次,对于文字高度比较好计算，但是对于单张图片的高度 ，这个就有点头疼了。曾经我问过一个朋友，他说服务器会直接反悔image的size 好吧 ，这个有这些数据的朋友们，当我没说。\n其次呢，没有怎么办呢，这个就是2次运行height函数的好处了。\n\n### 对于第一次函数 我们可以下载图片的缩略图以便在后面的计算高度中可以直接使用","slug":"IOS-UI-Tips-之UITabelviewCell-Height","published":1,"updated":"2015-08-18T06:04:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cidpaaq8u001aovfyraw3fhme"}],"PostAsset":[],"PostCategory":[{"post_id":"cidpaaq8a000eovfy7h1vif6r","category_id":"cidpaaq8a000fovfyads9vex6","_id":"cidpaaq8b000iovfy87p2xwpl"},{"post_id":"cidpaaq8e000movfygkmrtql1","category_id":"cidpaaq8e000novfy5q91yvu9","_id":"cidpaaq8f000qovfymbkc82w3"}],"PostTag":[{"post_id":"cidpaaq5h0000ovfy4qy5ri8k","tag_id":"cidpaaq5k0001ovfyeyapklwr","_id":"cidpaaq5l0002ovfy7dbc5vqt"},{"post_id":"cidpaaq850006ovfyna8vokp3","tag_id":"cidpaaq860007ovfy2ok276ak","_id":"cidpaaq860008ovfy40vy3axp"},{"post_id":"cidpaaq870009ovfyj1yd0ofx","tag_id":"cidpaaq5k0001ovfyeyapklwr","_id":"cidpaaq88000aovfyfb8frecw"},{"post_id":"cidpaaq88000bovfyhyw35fp5","tag_id":"cidpaaq89000covfy65h7q9x6","_id":"cidpaaq89000dovfyty792hx3"},{"post_id":"cidpaaq8a000eovfy7h1vif6r","tag_id":"cidpaaq8b000govfy7yevh1ff","_id":"cidpaaq8b000hovfyvqzhmtii"},{"post_id":"cidpaaq8c000jovfyxautaw3j","tag_id":"cidpaaq8d000kovfy9tal97gc","_id":"cidpaaq8d000lovfy7sv9uvym"},{"post_id":"cidpaaq8e000movfygkmrtql1","tag_id":"cidpaaq8f000oovfydj0qzkae","_id":"cidpaaq8f000povfyzqlmqhcs"},{"post_id":"cidpaaq8g000rovfyhitq31cx","tag_id":"cidpaaq8f000oovfydj0qzkae","_id":"cidpaaq8g000sovfy9ja4gibq"},{"post_id":"cidpaaq8h000tovfymbl6abeu","tag_id":"cidpaaq8i000uovfy8gdr1fd6","_id":"cidpaaq8i000vovfy9jas8j40"},{"post_id":"cidpaaq8j000wovfykwxio30h","tag_id":"cidpaaq89000covfy65h7q9x6","_id":"cidpaaq8j000xovfyasexm9z2"},{"post_id":"cidpaaq8k000yovfyw2i1e4dz","tag_id":"cidpaaq89000covfy65h7q9x6","_id":"cidpaaq8l000zovfyniwotm70"},{"post_id":"cidpaaq8m0010ovfy19ny9lx0","tag_id":"cidpaaq860007ovfy2ok276ak","_id":"cidpaaq8m0011ovfye058vpow"},{"post_id":"cidpaaq8n0012ovfyneuxcviu","tag_id":"cidpaaq5k0001ovfyeyapklwr","_id":"cidpaaq8o0013ovfyilv2unml"},{"post_id":"cidpaaq8p0014ovfyfrqcrk4p","tag_id":"cidpaaq5k0001ovfyeyapklwr","_id":"cidpaaq8q0015ovfyr7e72ppf"},{"post_id":"cidpaaq8q0016ovfyjz9a2d7k","tag_id":"cidpaaq5k0001ovfyeyapklwr","_id":"cidpaaq8r0017ovfyhoxdfh78"},{"post_id":"cidpaaq8t0018ovfybws4za80","tag_id":"cidpaaq5k0001ovfyeyapklwr","_id":"cidpaaq8u0019ovfyr7qwiyk2"},{"post_id":"cidpaaq8u001aovfyraw3fhme","tag_id":"cidpaaq8v001bovfyqy461mog","_id":"cidpaaq8v001covfyfltjssg7"}],"Tag":[{"name":"IOS","_id":"cidpaaq5k0001ovfyeyapklwr"},{"name":"实用小工具","_id":"cidpaaq860007ovfy2ok276ak"},{"name":"Objective-C","_id":"cidpaaq89000covfy65h7q9x6"},{"name":"NSRunLoop","_id":"cidpaaq8b000govfy7yevh1ff"},{"name":"自定义控件","_id":"cidpaaq8d000kovfy9tal97gc"},{"name":"随笔","_id":"cidpaaq8f000oovfydj0qzkae"},{"name":"Block","_id":"cidpaaq8i000uovfy8gdr1fd6"},{"name":"UI","_id":"cidpaaq8v001bovfyqy461mog"}]}}