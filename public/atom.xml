<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Vanday的博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-08-18T06:04:35.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Wangda]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[IOS-UI-Tips(-)之UITabelviewCell-Height]]></title>
    <link href="http://yoursite.com/2015/08/18/IOS-UI-Tips-%E4%B9%8BUITabelviewCell-Height/"/>
    <id>http://yoursite.com/2015/08/18/IOS-UI-Tips-之UITabelviewCell-Height/</id>
    <published>2015-08-18T03:36:07.000Z</published>
    <updated>2015-08-18T06:04:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UITableView中cell高度计算问题之">UITableView中cell高度计算问题之</h2><p>如何解决类似于微博cell高度问题</p>
<h3 id="首先我们先确定一下两个函数问题">首先我们先确定一下两个函数问题</h3><pre><code><span class="pp">- <span class="params">(<span class="variable">CGFloat</span>)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView heightForRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath

- <span class="params">(<span class="variable">UITableViewCell</span> *)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView cellForRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath</span>
</code></pre><p>根据我们一开始学习IOS时候的经验，height肯定是在UITableViewCell前面运行的。<br>实际上height虽说是在cell前面运行的，但是，cell运行完了以后，会再一次调用height,这个height才是cell的最终高度。这也就是说在整个tableview的刷新过程中每一个cell对应的height函数会调用2次,一前一后,这也是今天如何解决不规则cell高度的关键。</p>
<h3 id="我们拿到数据源_DataArray_执行_[self-tableView_reloadData]会执行">我们拿到数据源 DataArray 执行 [self.tableView reloadData]会执行</h3><pre><code><span class="pp">- <span class="params">(<span class="variable">CGFloat</span>)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView heightForRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath</span>
</code></pre><p>这个会遍历数组中的所有object 这个时候我们就可以在这里计算高度了(label、button、imageview)等,然后保存在mode中<br>等循环结束以后会执行</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">UITableViewCell</span> *)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView cellForRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath</span>
</code></pre><p>最后再调用</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">CGFloat</span>)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView heightForRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath</span>
</code></pre><p>现实在UITableView上。有些同学会觉得，运行了2次是不是很麻烦,首先呢 ，我想说的是，你知道这个调用顺序以后 可以优化时间 比如第一次计算高度的时候 就可以保存在模型中。后面2次都可以直接拿过来用。<br>其次,对于文字高度比较好计算，但是对于单张图片的高度 ，这个就有点头疼了。曾经我问过一个朋友，他说服务器会直接反悔image的size 好吧 ，这个有这些数据的朋友们，当我没说。<br>其次呢，没有怎么办呢，这个就是2次运行height函数的好处了。</p>
<h3 id="对于第一次函数_我们可以下载图片的缩略图以便在后面的计算高度中可以直接使用">对于第一次函数 我们可以下载图片的缩略图以便在后面的计算高度中可以直接使用</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="UITableView中cell高度计算问题之">UITableView中cell高度计算问题之</h2><p>如何解决类似于微博cell高度问题</p>
<h3 id="首先我们先确定一下两个函数问题">首先我们先确定一下两个函数问题</h3><pre><cod]]>
    </summary>
    
      <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C内存布局]]></title>
    <link href="http://yoursite.com/2015/08/17/Objective-C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2015/08/17/Objective-C内存布局/</id>
    <published>2015-08-17T10:06:49.000Z</published>
    <updated>2015-08-17T10:17:25.000Z</updated>
    <content type="html"><![CDATA[<p>对象(object)即一块内存，本文要探讨的是一个Objective-C对象在内存的布局(layout)问题，水果的官方文档有说，一个类(class)如果不需要从NSObject继承其某些特定的行为是不用继承NSObject的，这里我将讨论限制在继承了NSObject的类的对象范围内。</p>
<h3 id="首先来看一下，NSObject的定义：">首先来看一下，NSObject的定义：</h3><pre><code>@<span class="class"><span class="keyword">interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; {    </span>
     <span class="class"><span class="keyword">Class</span>    <span class="title">isa</span>;                      </span>
 } 
</code></pre><p>(由于我们讨论的是内存布局，因此将其方法的定义撇开)</p>
<p><strong>在Objective-C中，@interface关键字可以看着是C语言中的struct关键字的别名，当然他还会有一些其它功能，比如说让编译器知道@interface后后面的是一个Objective-C的类的名字等。但就我们研究其内存布局来说，我们简单地将其替换为struct，并将protocal定义去掉。因此，NSObject的定义就是样：</strong><br>struct NSObject{<br> 　　Class isa;<br>}</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对象(object)即一块内存，本文要探讨的是一个Objective-C对象在内存的布局(layout)问题，水果的官方文档有说，一个类(class)如果不需要从NSObject继承其某些特定的行为是不用继承NSObject的，这里我将讨论限制在继承了NSObject的类的]]>
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C消息机制的原理]]></title>
    <link href="http://yoursite.com/2015/08/17/Objective-C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2015/08/17/Objective-C消息机制的原理/</id>
    <published>2015-08-17T00:55:11.000Z</published>
    <updated>2015-08-17T09:12:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="在Objective-C中，message与方法的真正实现是在执行阶段绑定的，而非编译阶段。">在Objective-C中，message与方法的真正实现是在执行阶段绑定的，而非编译阶段。</h3><ul>
<li>编译器会将消息发送转换成对objc_msgSend方法的调用。</li>
<li>objc_msgSend方法含两个必要参数：receiver、方法名（即：selector），如：</li>
<li>[receiver message]，将被转换为：objc_msgSend(receiver, selector)</li>
<li>objc_msgSend方法也能hold住message的参数，如：</li>
<li>objc_msgSend(receiver, selector, arg1, arg2, …);</li>
</ul>
<h3 id="objc_msgSend方法会做按照顺序进行以下操作，以完成动态绑定">objc_msgSend方法会做按照顺序进行以下操作，以完成动态绑定</h3><ol>
<li>查找selector所指代的程序（方法的真正实现）。因为不同类对同一方法有不同的实现，所以对方法的真正实现的查找依赖于receiver的类</li>
<li>调用该实现，并将一系列参数传递过去</li>
<li>将该实现的返回值作为自己的返回值，返回之</li>
</ol>
<h4 id="消息传递的关键是，编译器构建每个类和对象时所采用的数据结构。每个类都包含以下两个必要元素：">消息传递的关键是，编译器构建每个类和对象时所采用的数据结构。每个类都包含以下两个必要元素：</h4><ul>
<li>一个指向父类的指针</li>
<li>一个调度表（dispatch table）。该调度表将类的selector与方法的实际内存地址关联起来</li>
<li>每个对象都有一个指向所属类的指针isa。通过该指针，对象可以找到它所属的类，也就找到了其全部父类，如下图所示：<br><img src="http://dangpu-wordpress.stor.sinaapp.com/uploads/2012/07/iPhone_Message.png" alt="ISA"></li>
</ul>
<p>当向一个对象发送消息时，objc_msgSend方法根据对象的isa指针找到对象的类，然后在类的调度表（dispatch table）中查找selector。如果无法找到selector，objc_msgSend通过指向父类的指针找到父类，并在父类的调度表（dispatch table）中查找selector，以此类推直到NSObject类。一旦查找到selector，objc_msgSend方法根据调度表的内存地址调用该实现。 通过这种方式，message与方法的真正实现在执行阶段才绑定。</p>
<p>为了保证消息发送与执行的效率，系统会将全部selector和使用过的方法的内存地址缓存起来。每个类都有一个独立的缓存，缓存包含有当前类自己的 selector以及继承自父类的selector。查找调度表（dispatch table）前，消息发送系统首先检查receiver对象的缓存。缓存命中的情况下，消息发送（messaging）比直接调用方法（function call）只慢一点点点点。</p>
<h4 id="关于Selector，什么_是Selector，Selector就是一个字符串，用来表示一个方法。">关于Selector，什么 是Selector，Selector就是一个字符串，用来表示一个方法。</h4><p>在Objective-C中，消息是直到运行的时候才和方法实现绑定的。编译器会把一个消息表达式，</p>
<p><code>[receiver message]</code></p>
<p>转换成一个对消息函数objc_msgSend的调用。该函数有两个主要参数：消息接收者和消息对应的方法名字——也就是方法选标：</p>
<p><code>objc_msgSend(receiver, selector)</code></p>
<p>同时接收消息中的任意数目的参数：</p>
<p><code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code><br>该消息函数做了动态绑定所需要的一切：</p>
<p><strong>它首先找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。</strong></p>
<p><strong>然后将消息接收者对象（指向消息接收者对象的指针）以及方法中指定的参数传给找到的方法实现。</strong></p>
<p><strong>最后，将方法实现的返回值作为该函数的返回值返回。</strong></p>
<p><strong>注意：编译器将自动插入调用该消息函数的代码。您无须在代码中显示调用该消息函数。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="在Objective-C中，message与方法的真正实现是在执行阶段绑定的，而非编译阶段。">在Objective-C中，message与方法的真正实现是在执行阶段绑定的，而非编译阶段。</h3><ul>
<li>编译器会将消息发送转换成对objc_msgSen]]>
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/2015/08/15/hello-world/"/>
    <id>http://yoursite.com/2015/08/15/hello-world/</id>
    <published>2015-08-15T03:36:07.000Z</published>
    <updated>2015-08-18T06:18:21.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
