<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Vanday的博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-08-17T07:13:30.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Wangda]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/2015/08/17/hello-world/"/>
    <id>http://yoursite.com/2015/08/17/hello-world/</id>
    <published>2015-08-17T07:13:30.000Z</published>
    <updated>2015-08-17T07:13:30.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C消息机制的原理]]></title>
    <link href="http://yoursite.com/2015/08/17/Objective-C%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2015/08/17/Objective-C消息机制的原理/</id>
    <published>2015-08-17T00:55:11.000Z</published>
    <updated>2015-08-17T09:12:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="在Objective-C中，message与方法的真正实现是在执行阶段绑定的，而非编译阶段。">在Objective-C中，message与方法的真正实现是在执行阶段绑定的，而非编译阶段。</h3><ul>
<li>编译器会将消息发送转换成对objc_msgSend方法的调用。</li>
<li>objc_msgSend方法含两个必要参数：receiver、方法名（即：selector），如：</li>
<li>[receiver message]，将被转换为：objc_msgSend(receiver, selector)</li>
<li>objc_msgSend方法也能hold住message的参数，如：</li>
<li>objc_msgSend(receiver, selector, arg1, arg2, …);</li>
</ul>
<h3 id="objc_msgSend方法会做按照顺序进行以下操作，以完成动态绑定">objc_msgSend方法会做按照顺序进行以下操作，以完成动态绑定</h3><ol>
<li>查找selector所指代的程序（方法的真正实现）。因为不同类对同一方法有不同的实现，所以对方法的真正实现的查找依赖于receiver的类</li>
<li>调用该实现，并将一系列参数传递过去</li>
<li>将该实现的返回值作为自己的返回值，返回之</li>
</ol>
<h4 id="消息传递的关键是，编译器构建每个类和对象时所采用的数据结构。每个类都包含以下两个必要元素：">消息传递的关键是，编译器构建每个类和对象时所采用的数据结构。每个类都包含以下两个必要元素：</h4><ul>
<li>一个指向父类的指针</li>
<li>一个调度表（dispatch table）。该调度表将类的selector与方法的实际内存地址关联起来</li>
<li>每个对象都有一个指向所属类的指针isa。通过该指针，对象可以找到它所属的类，也就找到了其全部父类，如下图所示：<br><img src="http://dangpu-wordpress.stor.sinaapp.com/uploads/2012/07/iPhone_Message.png" alt="ISA"></li>
</ul>
<p>当向一个对象发送消息时，objc_msgSend方法根据对象的isa指针找到对象的类，然后在类的调度表（dispatch table）中查找selector。如果无法找到selector，objc_msgSend通过指向父类的指针找到父类，并在父类的调度表（dispatch table）中查找selector，以此类推直到NSObject类。一旦查找到selector，objc_msgSend方法根据调度表的内存地址调用该实现。 通过这种方式，message与方法的真正实现在执行阶段才绑定。</p>
<p>为了保证消息发送与执行的效率，系统会将全部selector和使用过的方法的内存地址缓存起来。每个类都有一个独立的缓存，缓存包含有当前类自己的 selector以及继承自父类的selector。查找调度表（dispatch table）前，消息发送系统首先检查receiver对象的缓存。缓存命中的情况下，消息发送（messaging）比直接调用方法（function call）只慢一点点点点。</p>
<h4 id="关于Selector，什么_是Selector，Selector就是一个字符串，用来表示一个方法。">关于Selector，什么 是Selector，Selector就是一个字符串，用来表示一个方法。</h4><p>在Objective-C中，消息是直到运行的时候才和方法实现绑定的。编译器会把一个消息表达式，</p>
<p><code>[receiver message]</code></p>
<p>转换成一个对消息函数objc_msgSend的调用。该函数有两个主要参数：消息接收者和消息对应的方法名字——也就是方法选标：</p>
<p><code>objc_msgSend(receiver, selector)</code></p>
<p>同时接收消息中的任意数目的参数：</p>
<p><code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code><br>该消息函数做了动态绑定所需要的一切：</p>
<p><strong>它首先找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。</strong></p>
<p><strong>然后将消息接收者对象（指向消息接收者对象的指针）以及方法中指定的参数传给找到的方法实现。</strong></p>
<p><strong>最后，将方法实现的返回值作为该函数的返回值返回。</strong></p>
<p><strong>注意：编译器将自动插入调用该消息函数的代码。您无须在代码中显示调用该消息函数。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="在Objective-C中，message与方法的真正实现是在执行阶段绑定的，而非编译阶段。">在Objective-C中，message与方法的真正实现是在执行阶段绑定的，而非编译阶段。</h3><ul>
<li>编译器会将消息发送转换成对objc_msgSen]]>
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
</feed>
